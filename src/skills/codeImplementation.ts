/**
 * @file TooLoo.ai Skills OS - Code Implementation Skill
 * @description Skill that allows TooLoo to safely implement its own code suggestions
 * @version 1.0.0
 * @skill-os true
 */

import { z } from 'zod';
import type { Skill, KernelContext } from '../kernel/types.js';
import {
  getSafeImplementationService,
  type ImplementationRequest,
  type RiskLevel,
} from '@tooloo/skills';

// =============================================================================
// SCHEMAS
// =============================================================================

const FileOperationSchema = z.object({
  path: z.string().describe('Relative path from workspace root'),
  content: z.string().describe('File content to write'),
  action: z.enum(['create', 'modify', 'delete']).describe('Action to perform'),
});

const CodeImplementationInputSchema = z.object({
  files: z.array(FileOperationSchema).describe('Files to create or modify'),
  description: z.string().describe('Description of what this implementation does'),
  riskLevel: z
    .enum(['low', 'medium', 'high', 'critical'])
    .optional()
    .describe('Risk level for approval workflow'),
  autoApprove: z.boolean().default(false).describe('Whether to auto-approve if risk is low'),
  runTests: z.boolean().default(true).describe('Whether to run tests before deployment'),
  testPatterns: z.array(z.string()).optional().describe('Test file patterns to run'),
});

const CodeImplementationOutputSchema = z.object({
  success: z.boolean(),
  implementationId: z.string(),
  pipeline: z.object({
    staged: z.boolean(),
    verified: z.boolean(),
    tested: z.boolean(),
    approved: z.boolean(),
    deployed: z.boolean(),
    validated: z.boolean(),
  }),
  filesCreated: z.array(z.string()),
  filesModified: z.array(z.string()),
  filesDeleted: z.array(z.string()),
  errors: z.array(z.string()),
  warnings: z.array(z.string()),
  rollbackAvailable: z.boolean(),
  rollbackId: z.string().optional(),
});

// Use z.output for types after parsing (which applies defaults)
type CodeImplementationInput = z.output<typeof CodeImplementationInputSchema>;
type CodeImplementationOutput = z.output<typeof CodeImplementationOutputSchema>;

// =============================================================================
// SKILL DEFINITION
// =============================================================================

export const codeImplementationSkill: Skill<CodeImplementationInput, CodeImplementationOutput> = {
  id: 'code-implementation',
  name: 'Safe Code Implementation',
  version: '1.0.0',
  description:
    'Safely implements code suggestions generated by TooLoo.ai through a verified pipeline',
  category: 'system',

  // Schema - using 'as any' to bypass the complex ZodDefault typing issue
  schema: CodeImplementationInputSchema as any,
  outputSchema: CodeImplementationOutputSchema,

  // Intent matching
  intent: {
    triggers: [
      'implement',
      'create file',
      'write code',
      'deploy code',
      'self-implement',
      'generate file',
      'build component',
    ],
    priority: 90,
    classifier: (text: string) => {
      const lower = text.toLowerCase();
      const implementKeywords = [
        'implement',
        'create file',
        'write file',
        'deploy',
        'generate',
        'build',
        'make file',
      ];

      let score = 0;
      for (const keyword of implementKeywords) {
        if (lower.includes(keyword)) {
          score += 0.3;
        }
      }

      if (lower.includes('code') || lower.includes('file')) {
        score += 0.2;
      }

      return Math.min(score, 1);
    },
  },

  // UI configuration
  ui: {
    icon: 'üîß',
    placement: 'hidden',
  },

  // Component for rendering (path to lazy-loaded component)
  component: 'CodeImplementationView',

  // Execution
  async execute(input: CodeImplementationInput, context: KernelContext) {
    const service = getSafeImplementationService();

    // Build the implementation request
    const request: ImplementationRequest = {
      files: input.files.map((f) => ({
        path: f.path,
        content: f.content,
        action: f.action,
      })),
      description: input.description,
      riskLevel: input.riskLevel as RiskLevel | undefined,
      autoApprove: input.autoApprove,
      runTests: input.runTests,
      testPatterns: input.testPatterns,
      requestedBy: context.user?.id ?? 'system',
    };

    // Log to memory
    await context.services.memory.store({
      type: 'procedural',
      content: `Code implementation requested: ${input.description}`,
      importance: 8,
      metadata: { tags: ['implementation', 'self-modify'] },
    });

    // Emit event for monitoring
    context.services.emit('skill:implementation:start', {
      description: input.description,
      fileCount: input.files.length,
      riskLevel: input.riskLevel ?? 'auto-assessed',
    });

    // Execute the implementation pipeline
    const result = await service.implement(request);

    // Log result to memory
    await context.services.memory.store({
      type: result.success ? 'semantic' : 'episodic',
      content: result.success
        ? `Successfully implemented: ${input.description} (${result.filesCreated.length} created, ${result.filesModified.length} modified)`
        : `Failed to implement: ${input.description} - ${result.errors.join(', ')}`,
      importance: result.success ? 7 : 9,
      metadata: { tags: ['implementation', result.success ? 'success' : 'failure'] },
    });

    // Emit completion event
    context.services.emit('skill:implementation:complete', {
      implementationId: result.implementationId,
      success: result.success,
      pipeline: result.pipeline,
    });

    return result;
  },

  // Lifecycle hooks
  hooks: {
    onLoad: async (_context: KernelContext) => {
      console.log('[CodeImplementation] Skill loaded');
      getSafeImplementationService();
    },
  },
};

// =============================================================================
// ROLLBACK SKILL (companion skill)
// =============================================================================

const RollbackInputSchema = z.object({
  implementationId: z.string().describe('ID of the implementation to roll back'),
});

type RollbackInput = z.infer<typeof RollbackInputSchema>;
type RollbackOutput = { success: boolean; message: string };

export const rollbackSkill: Skill<RollbackInput, RollbackOutput> = {
  id: 'code-rollback',
  name: 'Code Rollback',
  version: '1.0.0',
  description: 'Rolls back a previous code implementation',
  category: 'system',

  schema: RollbackInputSchema,

  intent: {
    triggers: ['rollback', 'undo implementation', 'revert code'],
    priority: 85,
  },

  ui: {
    icon: '‚è™',
    placement: 'hidden',
  },

  component: 'CodeRollbackView',

  async execute(input: RollbackInput, context: KernelContext) {
    const service = getSafeImplementationService();
    const success = await service.rollbackById(input.implementationId);

    await context.services.memory.store({
      type: 'procedural',
      content: success
        ? `Rolled back implementation ${input.implementationId}`
        : `Failed to rollback implementation ${input.implementationId}`,
      importance: 8,
      metadata: { tags: ['rollback', success ? 'success' : 'failure'] },
    });

    return {
      success,
      message: success
        ? `Successfully rolled back implementation ${input.implementationId}`
        : `Could not find implementation ${input.implementationId} to roll back`,
    };
  },
};

export default codeImplementationSkill;
