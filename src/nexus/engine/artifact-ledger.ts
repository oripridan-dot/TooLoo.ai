// @version 2.1.28
/**
 * Artifact Ledger Engine
 *
 * Tracks every artifact generated by the system:
 * - Version history for each artifact
 * - Provenance chain (intent → task → score → decision)
 * - Rollback capability (restore previous versions)
 * - Audit trail for compliance
 * - Git integration for code artifacts
 *
 * Purpose: Complete auditability + zero-hallucination escape via traceability
 */

import { v4 as uuidv4 } from "uuid";
import fs from "fs/promises";
import path from "path";

export class ArtifactLedger {
  constructor(options = {}) {
    this.config = {
      storageDir: options.storageDir || process.cwd() + "/data/artifact-ledger",
      maxVersionsPerArtifact: options.maxVersionsPerArtifact || 50,
      enableGitIntegration: options.enableGitIntegration !== false,
      ...options,
    };

    this.ledger = new Map(); // artifactId → { versions: [], metadata }
    this.provenanceChains = new Map(); // artifactId → { intentId, dagId, tasks[], verdicts[] }
    this.stats = {
      totalArtifacts: 0,
      totalVersions: 0,
      totalRollbacks: 0,
      avgVersionsPerArtifact: 0,
    };

    this.initializeStorage();
  }

  async initializeStorage() {
    try {
      await fs.mkdir(this.config.storageDir, { recursive: true });
    } catch (e) {
      console.warn(`[ArtifactLedger] Storage init warning: ${e.message}`);
    }
  }

  /**
   * Register a new artifact
   */
  registerArtifact(artifactData) {
    const artifactId = artifactData.id || uuidv4();

    const artifact = {
      id: artifactId,
      type: artifactData.type, // 'code', 'document', 'design', 'analysis', 'config', 'data'
      title: artifactData.title || "Untitled",
      description: artifactData.description || "",
      mimeType: artifactData.mimeType || "text/plain",
      versions: [],
      metadata: {
        createdBy: artifactData.createdBy || "system",
        createdAt: new Date().toISOString(),
        tags: artifactData.tags || [],
        relatedIntentId: artifactData.relatedIntentId || null,
        relatedTaskId: artifactData.relatedTaskId || null,
      },
    };

    // Add first version
    const version1 = {
      versionId: 1,
      timestamp: new Date().toISOString(),
      content: artifactData.content,
      contentHash: this.hashContent(artifactData.content),
      changes: "Initial version",
      author: artifactData.createdBy || "system",
      confidence: artifactData.confidence || null,
      verdicts: [],
    };

    artifact.versions.push(version1);
    this.ledger.set(artifactId, artifact);

    // Initialize provenance
    this.provenanceChains.set(artifactId, {
      intentId: artifactData.relatedIntentId,
      dagId: artifactData.relatedDagId,
      nodeId: artifactData.relatedTaskId,
      tasks: [],
      verdicts: [],
      scores: [],
      decisions: [],
    });

    this.stats.totalArtifacts++;
    this.stats.totalVersions++;

    return {
      artifactId,
      versionId: 1,
      timestamp: version1.timestamp,
    };
  }

  /**
   * Add a new version to artifact
   */
  updateArtifact(artifactId, newContent, metadata = {}) {
    const artifact = this.ledger.get(artifactId);
    if (!artifact) throw new Error(`Artifact ${artifactId} not found`);

    // Calculate version number
    const nextVersion = artifact.versions.length + 1;

    // Enforce version limit
    if (artifact.versions.length >= this.config.maxVersionsPerArtifact) {
      // Remove oldest version
      artifact.versions.shift();
    }

    const newVersion = {
      versionId: nextVersion,
      timestamp: new Date().toISOString(),
      content: newContent,
      contentHash: this.hashContent(newContent),
      changes: metadata.changes || "Content updated",
      author: metadata.author || "system",
      confidence: metadata.confidence || null,
      verdicts: metadata.verdicts || [],
    };

    artifact.versions.push(newVersion);
    this.stats.totalVersions++;

    return {
      artifactId,
      versionId: nextVersion,
      timestamp: newVersion.timestamp,
    };
  }

  /**
   * Add verdict (score, decision, validation result)
   */
  addVerdict(artifactId, verdict) {
    const artifact = this.ledger.get(artifactId);
    if (!artifact) throw new Error(`Artifact ${artifactId} not found`);

    const currentVersion = artifact.versions[artifact.versions.length - 1];

    currentVersion.verdicts.push({
      verdictId: uuidv4(),
      timestamp: new Date().toISOString(),
      type: verdict.type, // 'confidence', 'review', 'test', 'security', 'compliance'
      score: verdict.score || null,
      decision: verdict.decision, // 'accept', 'reject', 'escalate', 'revision-needed'
      evidence: verdict.evidence || {},
      reviewer: verdict.reviewer || "system",
    });

    // Update provenance
    const provenance = this.provenanceChains.get(artifactId);
    if (provenance) {
      provenance.verdicts.push(verdict);
      provenance.scores.push(verdict.score);
    }

    return {
      artifactId,
      versionId: currentVersion.versionId,
      verdictCount: currentVersion.verdicts.length,
    };
  }

  /**
   * Get artifact with all versions
   */
  getArtifact(artifactId, versionId = null) {
    const artifact = this.ledger.get(artifactId);
    if (!artifact) return null;

    if (versionId === null) {
      // Return latest version
      const latestVersion = artifact.versions[artifact.versions.length - 1];
      return {
        ...artifact,
        currentVersion: latestVersion,
      };
    }

    // Return specific version
    const version = artifact.versions.find((v) => v.versionId === versionId);
    if (!version) return null;

    return {
      ...artifact,
      currentVersion: version,
    };
  }

  /**
   * Get artifact history (version diff timeline)
   */
  getHistory(artifactId) {
    const artifact = this.ledger.get(artifactId);
    if (!artifact) return null;

    return {
      artifactId,
      type: artifact.type,
      title: artifact.title,
      versions: artifact.versions.map((v, idx) => ({
        versionId: v.versionId,
        timestamp: v.timestamp,
        changes: v.changes,
        author: v.author,
        confidence: v.confidence,
        verdictCount: v.verdicts.length,
        contentLength: v.content.length,
        hash: v.contentHash,
        verdicts: v.verdicts.map((vd) => ({
          type: vd.type,
          decision: vd.decision,
          score: vd.score,
        })),
      })),
    };
  }

  /**
   * Rollback to previous version
   */
  rollback(artifactId, targetVersionId) {
    const artifact = this.ledger.get(artifactId);
    if (!artifact) throw new Error(`Artifact ${artifactId} not found`);

    const targetVersion = artifact.versions.find(
      (v) => v.versionId === targetVersionId,
    );
    if (!targetVersion) throw new Error(`Version ${targetVersionId} not found`);

    const currentVersion = artifact.versions[artifact.versions.length - 1];

    // Create rollback version
    const rollbackVersion = {
      versionId: currentVersion.versionId + 1,
      timestamp: new Date().toISOString(),
      content: targetVersion.content,
      contentHash: targetVersion.contentHash,
      changes: `Rolled back to version ${targetVersionId}`,
      author: "system-rollback",
      confidence: null,
      verdicts: [],
    };

    artifact.versions.push(rollbackVersion);
    this.stats.totalRollbacks++;
    this.stats.totalVersions++;

    return {
      artifactId,
      rolledBackTo: targetVersionId,
      newVersionId: rollbackVersion.versionId,
      timestamp: rollbackVersion.timestamp,
    };
  }

  /**
   * Get provenance chain (complete decision history)
   */
  getProvenance(artifactId) {
    const chain = this.provenanceChains.get(artifactId);
    if (!chain) return null;

    return {
      artifactId,
      intentId: chain.intentId,
      dagId: chain.dagId,
      nodeId: chain.nodeId,
      tasks: chain.tasks,
      verdicts: chain.verdicts.map((v) => ({
        type: v.type,
        score: v.score,
        decision: v.decision,
        evidence: v.evidence,
      })),
      scoreTimeline: chain.scores,
      decisionTimeline: chain.decisions,
      createdAt: chain.createdAt,
    };
  }

  /**
   * Search artifacts by criteria
   */
  searchArtifacts(criteria = {}) {
    const results = [];

    for (const [id, artifact] of this.ledger.entries()) {
      let matches = true;

      if (criteria.type && artifact.type !== criteria.type) matches = false;
      if (
        criteria.title &&
        !artifact.title.toLowerCase().includes(criteria.title.toLowerCase())
      )
        matches = false;
      if (criteria.tag && !artifact.metadata.tags.includes(criteria.tag))
        matches = false;
      if (
        criteria.intentId &&
        artifact.metadata.relatedIntentId !== criteria.intentId
      )
        matches = false;

      if (matches) {
        results.push({
          artifactId: id,
          type: artifact.type,
          title: artifact.title,
          versions: artifact.versions.length,
          createdAt: artifact.metadata.createdAt,
          tags: artifact.metadata.tags,
        });
      }
    }

    return results;
  }

  /**
   * Export artifact with full provenance
   */
  exportArtifact(artifactId, options = {}) {
    const artifact = this.getArtifact(artifactId);
    if (!artifact) throw new Error(`Artifact ${artifactId} not found`);

    const provenance = this.getProvenance(artifactId);

    return {
      artifact: {
        id: artifact.id,
        type: artifact.type,
        title: artifact.title,
        description: artifact.description,
        mimeType: artifact.mimeType,
        content: artifact.currentVersion.content,
        currentVersion: artifact.currentVersion.versionId,
        totalVersions: artifact.versions.length,
        metadata: artifact.metadata,
      },
      provenance,
      history: this.getHistory(artifactId),
      exportedAt: new Date().toISOString(),
    };
  }

  /**
   * Get statistics
   */
  getStats() {
    if (this.stats.totalArtifacts > 0) {
      this.stats.avgVersionsPerArtifact =
        this.stats.totalVersions / this.stats.totalArtifacts;
    }

    return { ...this.stats };
  }

  /**
   * Hash content for integrity checking
   */
  hashContent(content) {
    // Simple hash for demo; in production use crypto
    let hash = 0;
    const str = typeof content === "string" ? content : JSON.stringify(content);
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return `hash-${Math.abs(hash).toString(16)}`;
  }

  /**
   * Verify artifact integrity
   */
  verifyIntegrity(artifactId, versionId) {
    const artifact = this.getArtifact(artifactId, versionId);
    if (!artifact) return null;

    const version = artifact.currentVersion;
    const recomputedHash = this.hashContent(version.content);

    return {
      artifactId,
      versionId: version.versionId,
      storedHash: version.contentHash,
      computedHash: recomputedHash,
      isValid: version.contentHash === recomputedHash,
    };
  }

  /**
   * Clear all data
   */
  clear() {
    this.ledger.clear();
    this.provenanceChains.clear();
    this.stats = {
      totalArtifacts: 0,
      totalVersions: 0,
      totalRollbacks: 0,
      avgVersionsPerArtifact: 0,
    };
  }
}

/**
 * Create Express integration for Artifact Ledger
 */
export async function createArtifactLedgerServer(ledger, options = {}) {
  const express = (await import("express")).default;
  const app = express();

  app.use(express.json());

  const ok = (data) => ({ ok: true, ...data });
  const err = (e) => ({ ok: false, error: e?.message || String(e) });

  // POST /api/v1/artifacts/register
  app.post("/api/v1/artifacts/register", (req, res) => {
    try {
      const result = ledger.registerArtifact(req.body);
      res.json(ok(result));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // POST /api/v1/artifacts/{id}/update
  app.post("/api/v1/artifacts/:id/update", (req, res) => {
    try {
      const { content, changes, author, confidence } = req.body;
      const result = ledger.updateArtifact(req.params.id, content, {
        changes,
        author,
        confidence,
      });
      res.json(ok(result));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // POST /api/v1/artifacts/{id}/verdict
  app.post("/api/v1/artifacts/:id/verdict", (req, res) => {
    try {
      const result = ledger.addVerdict(req.params.id, req.body);
      res.json(ok(result));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // GET /api/v1/artifacts/{id}
  app.get("/api/v1/artifacts/:id", (req, res) => {
    try {
      const versionId = req.query.versionId
        ? Number(req.query.versionId)
        : null;
      const artifact = ledger.getArtifact(req.params.id, versionId);
      if (!artifact) return res.status(404).json(err("Artifact not found"));
      res.json(ok({ artifact }));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // GET /api/v1/artifacts/{id}/history
  app.get("/api/v1/artifacts/:id/history", (req, res) => {
    try {
      const history = ledger.getHistory(req.params.id);
      if (!history) return res.status(404).json(err("Artifact not found"));
      res.json(ok({ history }));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // POST /api/v1/artifacts/{id}/rollback
  app.post("/api/v1/artifacts/:id/rollback", (req, res) => {
    try {
      const { targetVersionId } = req.body;
      const result = ledger.rollback(req.params.id, targetVersionId);
      res.json(ok(result));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // GET /api/v1/artifacts/{id}/provenance
  app.get("/api/v1/artifacts/:id/provenance", (req, res) => {
    try {
      const provenance = ledger.getProvenance(req.params.id);
      if (!provenance) return res.status(404).json(err("Provenance not found"));
      res.json(ok({ provenance }));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // GET /api/v1/artifacts/search
  app.get("/api/v1/artifacts/search", (req, res) => {
    try {
      const results = ledger.searchArtifacts({
        type: req.query.type,
        title: req.query.title,
        tag: req.query.tag,
        intentId: req.query.intentId,
      });
      res.json(ok({ results, count: results.length }));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // GET /api/v1/artifacts/{id}/export
  app.get("/api/v1/artifacts/:id/export", (req, res) => {
    try {
      const exported = ledger.exportArtifact(req.params.id);
      res.json(ok({ exported }));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // GET /api/v1/artifacts/stats
  app.get("/api/v1/artifacts/stats", (req, res) => {
    try {
      const stats = ledger.getStats();
      res.json(ok({ stats }));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  return app;
}

export default ArtifactLedger;
