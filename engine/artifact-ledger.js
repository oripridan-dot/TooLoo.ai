/**
 * Artifact Ledger Engine
 * 
 * Tracks every artifact generated by the system:
 * - Version history for each artifact
 * - Provenance chain (intent → task → score → decision)
 * - Rollback capability (restore previous versions)
 * - Audit trail for compliance
 * - Git integration for code artifacts
 * 
 * Purpose: Complete auditability + zero-hallucination escape via traceability
 */

import { v4 as uuidv4 } from 'uuid';
import fs from 'fs/promises';
import path from 'path';

export class ArtifactLedger {
  constructor(options = {}) {
    this.config = {
      storageDir: options.storageDir || process.cwd() + '/data/artifact-ledger',
      maxVersionsPerArtifact: options.maxVersionsPerArtifact || 50,
      enableGitIntegration: options.enableGitIntegration !== false,
      ...options
    };

    this.ledger = new Map(); // artifactId → { versions: [], metadata }
    this.provenanceChains = new Map(); // artifactId → { intentId, dagId, tasks[], verdicts[] }
    this.stats = {
      totalArtifacts: 0,
      totalVersions: 0,
      totalRollbacks: 0,
      avgVersionsPerArtifact: 0
    };

    this.initializeStorage();
  }

  async initializeStorage() {
    try {
      await fs.mkdir(this.config.storageDir, { recursive: true });
    } catch (e) {
      console.warn(`[ArtifactLedger] Storage init warning: ${e.message}`);
    }
  }

  /**
   * Register a new artifact
   */
  registerArtifact(artifactData) {
    const artifactId = artifactData.id || uuidv4();

    const artifact = {
      id: artifactId,
      type: artifactData.type, // 'code', 'document', 'design', 'analysis', 'config', 'data'
      title: artifactData.title || 'Untitled',
      description: artifactData.description || '',
      mimeType: artifactData.mimeType || 'text/plain',
      versions: [],
      metadata: {
        createdBy: artifactData.createdBy || 'system',
        createdAt: new Date().toISOString(),
        tags: artifactData.tags || [],
        relatedIntentId: artifactData.relatedIntentId || null,
        relatedTaskId: artifactData.relatedTaskId || null
      }
    };

    // Add first version
    const version1 = {
      versionId: 1,
      timestamp: new Date().toISOString(),
      content: artifactData.content,
      contentHash: this.hashContent(artifactData.content),
      changes: 'Initial version',
      author: artifactData.createdBy || 'system',
      confidence: artifactData.confidence || null,
      verdicts: []
    };

    artifact.versions.push(version1);
    this.ledger.set(artifactId, artifact);

    // Initialize provenance
    this.provenanceChains.set(artifactId, {
      intentId: artifactData.relatedIntentId,
      dagId: artifactData.relatedDagId,
      nodeId: artifactData.relatedTaskId,
      tasks: [],
      verdicts: [],
      scores: [],
      decisions: []
    });

    this.stats.totalArtifacts++;
    this.stats.totalVersions++;

    return {
      artifactId,
      versionId: 1,
      timestamp: version1.timestamp
    };
  }

  /**
   * Add a new version to artifact
   */
  updateArtifact(artifactId, newContent, metadata = {}) {
    const artifact = this.ledger.get(artifactId);
    if (!artifact) throw new Error(`Artifact ${artifactId} not found`);

    // Calculate version number
    const nextVersion = artifact.versions.length + 1;

    // Enforce version limit
    if (artifact.versions.length >= this.config.maxVersionsPerArtifact) {
      // Remove oldest version
      artifact.versions.shift();
    }

    const newVersion = {
      versionId: nextVersion,
      timestamp: new Date().toISOString(),
      content: newContent,
      contentHash: this.hashContent(newContent),
      changes: metadata.changes || 'Content updated',
      author: metadata.author || 'system',
      confidence: metadata.confidence || null,
      verdicts: metadata.verdicts || []
    };

    artifact.versions.push(newVersion);
    this.stats.totalVersions++;

    return {
      artifactId,
      versionId: nextVersion,
      timestamp: newVersion.timestamp
    };
  }

  /**
   * Add verdict (score, decision, validation result)
   */
  addVerdict(artifactId, verdict) {
    const artifact = this.ledger.get(artifactId);
    if (!artifact) throw new Error(`Artifact ${artifactId} not found`);

    const currentVersion = artifact.versions[artifact.versions.length - 1];

    currentVersion.verdicts.push({
      verdictId: uuidv4(),
      timestamp: new Date().toISOString(),
      type: verdict.type, // 'confidence', 'review', 'test', 'security', 'compliance'
      score: verdict.score || null,
      decision: verdict.decision, // 'accept', 'reject', 'escalate', 'revision-needed'
      evidence: verdict.evidence || {},
      reviewer: verdict.reviewer || 'system'
    });

    // Update provenance
    const provenance = this.provenanceChains.get(artifactId);
    if (provenance) {
      provenance.verdicts.push(verdict);
      provenance.scores.push(verdict.score);
    }

    return {
      artifactId,
      versionId: currentVersion.versionId,
      verdictCount: currentVersion.verdicts.length
    };
  }

  /**
   * Get artifact with all versions
   */
  getArtifact(artifactId, versionId = null) {
    const artifact = this.ledger.get(artifactId);
    if (!artifact) return null;

    if (versionId === null) {
      // Return latest version
      const latestVersion = artifact.versions[artifact.versions.length - 1];
      return {
        ...artifact,
        currentVersion: latestVersion
      };
    }

    // Return specific version
    const version = artifact.versions.find(v => v.versionId === versionId);
    if (!version) return null;

    return {
      ...artifact,
      currentVersion: version
    };
  }

  /**
   * Get artifact history (version diff timeline)
   */
  getHistory(artifactId) {
    const artifact = this.ledger.get(artifactId);
    if (!artifact) return null;

    return {
      artifactId,
      type: artifact.type,
      title: artifact.title,
      versions: artifact.versions.map((v, idx) => ({
        versionId: v.versionId,
        timestamp: v.timestamp,
        changes: v.changes,
        author: v.author,
        confidence: v.confidence,
        verdictCount: v.verdicts.length,
        contentLength: v.content.length,
        hash: v.contentHash,
        verdicts: v.verdicts.map(vd => ({
          type: vd.type,
          decision: vd.decision,
          score: vd.score
        }))
      }))
    };
  }

  /**
   * Rollback to previous version
   */
  rollback(artifactId, targetVersionId) {
    const artifact = this.ledger.get(artifactId);
    if (!artifact) throw new Error(`Artifact ${artifactId} not found`);

    const targetVersion = artifact.versions.find(v => v.versionId === targetVersionId);
    if (!targetVersion) throw new Error(`Version ${targetVersionId} not found`);

    const currentVersion = artifact.versions[artifact.versions.length - 1];

    // Create rollback version
    const rollbackVersion = {
      versionId: currentVersion.versionId + 1,
      timestamp: new Date().toISOString(),
      content: targetVersion.content,
      contentHash: targetVersion.contentHash,
      changes: `Rolled back to version ${targetVersionId}`,
      author: 'system-rollback',
      confidence: null,
      verdicts: []
    };

    artifact.versions.push(rollbackVersion);
    this.stats.totalRollbacks++;
    this.stats.totalVersions++;

    return {
      artifactId,
      rolledBackTo: targetVersionId,
      newVersionId: rollbackVersion.versionId,
      timestamp: rollbackVersion.timestamp
    };
  }

  /**
   * Get provenance chain (complete decision history)
   */
  getProvenance(artifactId) {
    const chain = this.provenanceChains.get(artifactId);
    if (!chain) return null;

    return {
      artifactId,
      intentId: chain.intentId,
      dagId: chain.dagId,
      nodeId: chain.nodeId,
      tasks: chain.tasks,
      verdicts: chain.verdicts.map(v => ({
        type: v.type,
        score: v.score,
        decision: v.decision,
        evidence: v.evidence
      })),
      scoreTimeline: chain.scores,
      decisionTimeline: chain.decisions,
      createdAt: chain.createdAt
    };
  }

  /**
   * Search artifacts by criteria
   */
  searchArtifacts(criteria = {}) {
    const results = [];

    for (const [id, artifact] of this.ledger.entries()) {
      let matches = true;

      if (criteria.type && artifact.type !== criteria.type) matches = false;
      if (criteria.title && !artifact.title.toLowerCase().includes(criteria.title.toLowerCase())) matches = false;
      if (criteria.tag && !artifact.metadata.tags.includes(criteria.tag)) matches = false;
      if (criteria.intentId && artifact.metadata.relatedIntentId !== criteria.intentId) matches = false;

      if (matches) {
        results.push({
          artifactId: id,
          type: artifact.type,
          title: artifact.title,
          versions: artifact.versions.length,
          createdAt: artifact.metadata.createdAt,
          tags: artifact.metadata.tags
        });
      }
    }

    return results;
  }

  /**
   * Export artifact with full provenance
   */
  exportArtifact(artifactId, options = {}) {
    const artifact = this.getArtifact(artifactId);
    if (!artifact) throw new Error(`Artifact ${artifactId} not found`);

    const provenance = this.getProvenance(artifactId);

    return {
      artifact: {
        id: artifact.id,
        type: artifact.type,
        title: artifact.title,
        description: artifact.description,
        mimeType: artifact.mimeType,
        content: artifact.currentVersion.content,
        currentVersion: artifact.currentVersion.versionId,
        totalVersions: artifact.versions.length,
        metadata: artifact.metadata
      },
      provenance,
      history: this.getHistory(artifactId),
      exportedAt: new Date().toISOString()
    };
  }

  /**
   * Get statistics
   */
  getStats() {
    if (this.stats.totalArtifacts > 0) {
      this.stats.avgVersionsPerArtifact = this.stats.totalVersions / this.stats.totalArtifacts;
    }

    return { ...this.stats };
  }

  /**
   * Hash content for integrity checking
   */
  hashContent(content) {
    // Simple hash for demo; in production use crypto
    let hash = 0;
    const str = typeof content === 'string' ? content : JSON.stringify(content);
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return `hash-${Math.abs(hash).toString(16)}`;
  }

  /**
   * Verify artifact integrity
   */
  verifyIntegrity(artifactId, versionId) {
    const artifact = this.getArtifact(artifactId, versionId);
    if (!artifact) return null;

    const version = artifact.currentVersion;
    const recomputedHash = this.hashContent(version.content);

    return {
      artifactId,
      versionId: version.versionId,
      storedHash: version.contentHash,
      computedHash: recomputedHash,
      isValid: version.contentHash === recomputedHash
    };
  }

  /**
   * Clear all data
   */
  clear() {
    this.ledger.clear();
    this.provenanceChains.clear();
    this.stats = {
      totalArtifacts: 0,
      totalVersions: 0,
      totalRollbacks: 0,
      avgVersionsPerArtifact: 0
    };
  }
}

/**
 * Create Express integration for Artifact Ledger
 */
export async function createArtifactLedgerServer(ledger, options = {}) {
  const express = (await import('express')).default;
  const app = express();

  app.use(express.json());

  const ok = (data) => ({ ok: true, ...data });
  const err = (e) => ({ ok: false, error: e?.message || String(e) });

  // POST /api/v1/artifacts/register
  app.post('/api/v1/artifacts/register', (req, res) => {
    try {
      const result = ledger.registerArtifact(req.body);
      res.json(ok(result));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // POST /api/v1/artifacts/{id}/update
  app.post('/api/v1/artifacts/:id/update', (req, res) => {
    try {
      const { content, changes, author, confidence } = req.body;
      const result = ledger.updateArtifact(req.params.id, content, {
        changes,
        author,
        confidence
      });
      res.json(ok(result));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // POST /api/v1/artifacts/{id}/verdict
  app.post('/api/v1/artifacts/:id/verdict', (req, res) => {
    try {
      const result = ledger.addVerdict(req.params.id, req.body);
      res.json(ok(result));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // GET /api/v1/artifacts/{id}
  app.get('/api/v1/artifacts/:id', (req, res) => {
    try {
      const versionId = req.query.versionId ? Number(req.query.versionId) : null;
      const artifact = ledger.getArtifact(req.params.id, versionId);
      if (!artifact) return res.status(404).json(err('Artifact not found'));
      res.json(ok({ artifact }));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // GET /api/v1/artifacts/{id}/history
  app.get('/api/v1/artifacts/:id/history', (req, res) => {
    try {
      const history = ledger.getHistory(req.params.id);
      if (!history) return res.status(404).json(err('Artifact not found'));
      res.json(ok({ history }));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // POST /api/v1/artifacts/{id}/rollback
  app.post('/api/v1/artifacts/:id/rollback', (req, res) => {
    try {
      const { targetVersionId } = req.body;
      const result = ledger.rollback(req.params.id, targetVersionId);
      res.json(ok(result));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // GET /api/v1/artifacts/{id}/provenance
  app.get('/api/v1/artifacts/:id/provenance', (req, res) => {
    try {
      const provenance = ledger.getProvenance(req.params.id);
      if (!provenance) return res.status(404).json(err('Provenance not found'));
      res.json(ok({ provenance }));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // GET /api/v1/artifacts/search
  app.get('/api/v1/artifacts/search', (req, res) => {
    try {
      const results = ledger.searchArtifacts({
        type: req.query.type,
        title: req.query.title,
        tag: req.query.tag,
        intentId: req.query.intentId
      });
      res.json(ok({ results, count: results.length }));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // GET /api/v1/artifacts/{id}/export
  app.get('/api/v1/artifacts/:id/export', (req, res) => {
    try {
      const exported = ledger.exportArtifact(req.params.id);
      res.json(ok({ exported }));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  // GET /api/v1/artifacts/stats
  app.get('/api/v1/artifacts/stats', (req, res) => {
    try {
      const stats = ledger.getStats();
      res.json(ok({ stats }));
    } catch (e) {
      res.status(400).json(err(e));
    }
  });

  return app;
}

export default ArtifactLedger;
