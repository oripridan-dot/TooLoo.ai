#!/usr/bin/env node
/**
 * TooLoo.ai Simple API Server
 * Personal AI Development Assistant - Single User Focus
 * 
 * Purpose: Lean, reliable backend for personal use
 * No complex monorepo - just what you need to build apps
 */

const express = require('express');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const cors = require('cors');
const path = require('path');
const { createServer } = require('http');
const { Server } = require('socket.io');
const SecureCodeExecutor = require('./secure-code-executor');
const PersonalFilesystemManager = require('./personal-filesystem-manager');
const SelfAwarenessManager = require('./self-awareness-manager');
const SelfInspectionManager = require('./self-inspection-manager');
const SelfImplementationWizard = require('./self-implementation-wizard');
const ChangeOrchestrator = require('./change-orchestrator');
const GitHubManager = require('./github-manager');
const EnvironmentHub = require('./environment-hub');
const ToolooUIGenerator = require('./tooloo-ui-generator');
require('dotenv').config();

// Crash Prevention - Handle uncaught exceptions and rejections
process.on('uncaughtException', (error) => {
  console.error('üö® Uncaught Exception:', error);
  console.error('üí° TooLoo will continue running...');
  // Don't exit - keep the server running
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('üö® Unhandled Rejection at:', promise, 'reason:', reason);
  console.error('üí° TooLoo will continue running...');
  // Don't exit - keep the server running
});

// Graceful shutdown handler
process.on('SIGTERM', () => {
  console.log('üîÑ SIGTERM received. Shutting down gracefully...');
  server.close(() => {
    console.log('‚úÖ HTTP server closed.');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('üîÑ SIGINT received. Shutting down gracefully...');
  server.close(() => {
    console.log('‚úÖ HTTP server closed.');
    process.exit(0);
  });
});

const app = express();
// Behind GitHub Codespaces/other proxies, trust X-Forwarded-* headers
app.set('trust proxy', 1);
const server = createServer(app);
const distDir = path.join(__dirname, 'web-app', 'dist');
const corsOptions = {
  origin: (origin, callback) => {
    // Allow all origins in development (GitHub Codespaces, localhost, etc.)
    callback(null, true);
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept', 'Origin'],
  exposedHeaders: ['Content-Range', 'X-Content-Range'],
  maxAge: 86400 // 24 hours
};

const io = new Server(server, {
  cors: {
    origin: true,
    credentials: true,
    methods: ["GET", "POST", "OPTIONS"],
  }
});

// Middleware - CORS must be first
app.use(cors(corsOptions));
// Enable pre-flight for all routes
app.use((req, res, next) => {
  if (req.method === 'OPTIONS') {
    res.header('Access-Control-Allow-Origin', req.headers.origin || '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');
    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With, Accept, Origin');
    res.header('Access-Control-Allow-Credentials', 'true');
    res.header('Access-Control-Max-Age', '86400');
    return res.sendStatus(200);
  }
  next();
});
app.use(express.json({ limit: '10mb' }));
// Basic security headers
app.use(helmet({
  contentSecurityPolicy: false, // disable CSP for local dev simplicity
  crossOriginResourcePolicy: false, // Allow cross-origin resource loading
  crossOriginOpenerPolicy: false,
  crossOriginEmbedderPolicy: false
}));
// Rate limiting for API routes to mitigate abuse
const apiLimiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS || `${15 * 60 * 1000}`),
  max: parseInt(process.env.RATE_LIMIT_MAX || '300'),
  standardHeaders: true,
  legacyHeaders: false
});
app.use('/api/', apiLimiter);

// API server should NOT serve UI - redirect to the React app on port 5173
app.get('/', (req, res) => {
  res.redirect('http://localhost:5173');
});

// Legacy routes - redirect to React app
app.get('/cuberto-interface.html', (req, res) => {
  res.redirect('http://localhost:5173');
});

app.get('/test-ui-generation.html', (req, res) => {
  res.redirect('http://localhost:5173');
});

// Serve UI builder
app.get('/tooloo-ui-builder.html', (req, res) => {
  return res.sendFile(path.join(__dirname, 'tooloo-ui-builder.html'));
});

// SPA history fallback for any non-API routes when dist exists
app.get(/^(?!\/api\/).+/, (req, res, next) => {
  if (req.method !== 'GET') return next();
  // If dist index.html exists, serve it; otherwise continue (will 404 or hit other routes)
  const indexPath = path.join(distDir, 'index.html');
  try {
    return res.sendFile(indexPath);
  } catch {
    return next();
  }
});

// Personal AI Provider Manager
class PersonalAIManager {
  constructor() {
    this.providers = new Map();
    this.userPreferences = {
      defaultProvider: 'deepseek', // Cost-effective for personal use
      learningEnabled: true,
      autoExecute: false // Safety first
    };
    this.codeExecutor = new SecureCodeExecutor();
    this.filesystemManager = new PersonalFilesystemManager({
      workspaceRoot: process.cwd(),
      projectsDir: process.cwd() + '/personal-projects'
    });
    this.selfAwarenessManager = new SelfAwarenessManager({
      workspaceRoot: process.cwd()
    });
    this.changeOrchestrator = new ChangeOrchestrator({
      workspaceRoot: process.cwd(),
      filesystemManager: this.filesystemManager,
      selfAwareness: this.selfAwarenessManager
    });
    this.selfImplementationWizard = new SelfImplementationWizard({
      workspaceRoot: process.cwd(),
      changeOrchestrator: this.changeOrchestrator,
      filesystemManager: this.filesystemManager
    });
    this.github = new GitHubManager({
      defaultOwner: 'oripridan-dot',
      defaultRepo: 'TooLoo.ai'
    });
    this.environmentHub = new EnvironmentHub({
      workspaceRoot: process.cwd(),
      mode: 'self-aware'
    });
    this.selfInspection = new SelfInspectionManager({
      workspaceRoot: process.cwd()
    });
    this.selfAwarenessEnabled = true; // Enable self-awareness by default
    this.offline = process.env.OFFLINE_ONLY === 'true';
    
    // CONVERSATIONAL SETTINGS - NO CODE MODE!
    this.showCode = false; // NEVER show code blocks in responses
    this.actionMode = true; // ALWAYS execute, never just explain
    this.conversationalStyle = 'friendly'; // Be conversational, not technical
    
    console.log('üß† Self-awareness enabled by default - TooLoo.ai can view and modify its own code');
    console.log('üí¨ Conversational mode: ACTION-FIRST (No code shown, just results!)');
    this.initializeProviders();
    this.initializeEnvironmentHub();
    this.initializeSelfInspection();
    this.initializeInstructionMaintenance();
  }

  /**
   * Initialize instruction maintenance system
   * Keeps AI agent instructions synchronized with codebase
   */
  async initializeInstructionMaintenance() {
    console.log('üìö Initializing AI instruction maintenance...');
    
    // Check instruction file health every 6 hours
    const checkInterval = 6 * 60 * 60 * 1000; // 6 hours
    
    const checkInstructionHealth = async () => {
      try {
        const instructionFiles = [
          '.github/copilot-instructions.md',
          '.github/OPENAI-GPT-INSTRUCTIONS.md',
          '.github/CLAUDE-INSTRUCTIONS.md',
          '.github/GEMINI-INSTRUCTIONS.md'
        ];
        
        const fs = require('fs').promises;
        const path = require('path');
        
        let needsUpdate = false;
        const now = Date.now();
        const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);
        
        for (const file of instructionFiles) {
          const filePath = path.join(process.cwd(), file);
          try {
            const stats = await fs.stat(filePath);
            if (stats.mtime.getTime() < thirtyDaysAgo) {
              needsUpdate = true;
              console.log(`‚ö†Ô∏è  ${file} hasn't been updated in 30+ days`);
            }
          } catch (error) {
            console.log(`‚ö†Ô∏è  ${file} not found`);
            needsUpdate = true;
          }
        }
        
        if (needsUpdate) {
          console.log('\n' + '='.repeat(60));
          console.log('üìù AI INSTRUCTION UPDATE RECOMMENDED');
          console.log('Some instruction files are outdated or missing.');
          console.log('Run: npm run update-instructions (when implemented)');
          console.log('='.repeat(60) + '\n');
        } else {
          console.log('‚úÖ All AI instruction files are up to date');
        }
      } catch (error) {
        console.error('‚ùå Error checking instruction health:', error.message);
      }
    };
    
    // Initial check after 10 seconds
    setTimeout(checkInstructionHealth, 10000);
    
    // Periodic check every 6 hours
    setInterval(checkInstructionHealth, checkInterval);
    
    console.log('üìö Instruction maintenance scheduled (checks every 6 hours)');
  }

  /**
   * Initialize self-inspection with smart scheduling
   */
  async initializeSelfInspection() {
    console.log('üîç Initializing self-inspection routine...');
    
    // Check on startup if inspection is needed
    setTimeout(async () => {
      const decision = await this.selfInspection.shouldRunInspection();
      if (decision.shouldInspect) {
        console.log('\n' + '='.repeat(60));
        console.log(decision.summary.message);
        console.log(decision.summary.details);
        console.log('='.repeat(60) + '\n');
        
        console.log('üí° TooLoo recommends running inspection. Type "inspect repository" to start.');
      } else {
        console.log(decision.summary.message);
      }
    }, 5000); // Check 5 seconds after startup
    
    // Start smart auto-inspection (checks every 6 hours)
    this.selfInspection.startAutoInspection('smart');
  }

  initializeProviders() {
    // Free tier - Hugging Face
    if (process.env.HF_API_KEY) {
      this.providers.set('huggingface', {
        name: 'Hugging Face (Free)',
        endpoint: 'https://api-inference.huggingface.co/models/microsoft/DialoGPT-medium',
        headers: { 'Authorization': `Bearer ${process.env.HF_API_KEY}` },
        cost: 0,
        enabled: true
      });
    }

    // Paid providers - only if keys exist
    const paidProviders = [
      { key: 'DEEPSEEK_API_KEY', name: 'deepseek', displayName: 'DeepSeek (Code Focus)' },
      { key: 'ANTHROPIC_API_KEY', name: 'claude', displayName: 'Claude (Reasoning)' },
      { key: 'OPENAI_API_KEY', name: 'openai', displayName: 'GPT-4 (Reliable)' },
      { key: 'GEMINI_API_KEY', name: 'gemini', displayName: 'Gemini (Creative)' },
      { key: 'XAI_API_KEY', name: 'grok', displayName: 'Grok (Experimental)' }
    ];

    paidProviders.forEach(provider => {
      if (process.env[provider.key]) {
        this.providers.set(provider.name, {
          name: provider.displayName,
          apiKey: process.env[provider.key],
          enabled: true
        });
      }
    });

    console.log(`ü§ñ Initialized ${this.providers.size} AI providers for personal use`);
  }

  initializeEnvironmentHub() {
    // Register all components with the Environment Hub
    this.environmentHub.registerComponent('filesystemManager', this.filesystemManager, [
      'filesystem-management', 'file-operations', 'project-creation'
    ]);
    
    this.environmentHub.registerComponent('selfAwarenessManager', this.selfAwarenessManager, [
      'self-awareness', 'code-analysis', 'code-modification'
    ]);
    
    this.environmentHub.registerComponent('githubManager', this.github, [
      'github-integration', 'repository-access', 'remote-code-access'
    ]);
    
    this.environmentHub.registerComponent('codeExecutor', this.codeExecutor, [
      'code-execution', 'security-validation'
    ]);
    
    this.environmentHub.registerComponent('aiManager', this, [
      'ai-provider', 'response-generation', 'intent-parsing'
    ]);

    this.environmentHub.registerComponent('changeOrchestrator', this.changeOrchestrator, [
      'code-change-management', 'session-orchestration', 'validation-runner'
    ]);
    
    // Start the Environment Hub
    this.environmentHub.start();
    
    console.log('üåç Environment Hub initialized with all system components');
  }

  async generateResponse(prompt, context = {}) {
    const selectedProvider = this.selectBestProvider(prompt, context);
    
    try {
      // Check if this is a self-implementation request (WIZARD MODE!)
      const implRequest = await this.selfImplementationWizard.parseImplementationRequest(prompt);
      if (implRequest) {
        console.log('üßô Self-Implementation Wizard activated!');
        const result = await this.selfImplementationWizard.executeImplementation(implRequest);
        const structuredSummary = result.structuredSummary || null;
        return {
          content: result.conversationalResponse,
          provider: 'self-implementation-wizard',
          cost: 0,
          tokens: { input: 0, output: 0 },
          implementation: result,
          structuredSummary,
          changeSession: result.changeSession || null,
          sessionTimeline: result.sessionTimeline || null
        };
      }

      // Check if this is a UI generation request
      const uiRequest = this.parseUIRequest(prompt);
      if (uiRequest.isUIRequest) {
        return await this.handleUIRequest(uiRequest, prompt);
      }

      // Check if this is a filesystem command
      const fsCommand = this.parseFilesystemCommand(prompt);
      if (fsCommand) {
        return await this.handleFilesystemCommand(fsCommand, prompt);
      }

      // If offline mode is enabled, don't call external providers
      if (this.offline) {
        return {
          content: `## Offline Mode Enabled\n\nExternal AI calls are disabled to save tokens. I can still help you manage your files and scaffold projects. Try commands like:\n\n- list files\n- create project MyApp\n- write file MyApp/index.html with content ...\n- read file MyApp/index.html\n- search files for "TODO"`,
          provider: 'offline',
          cost: 0,
          tokens: { input: 0, output: 0 }
        };
      }

      // Enhance prompt with filesystem context if building an app
      const enhancedPrompt = await this.enhancePromptWithContext(prompt, context);
      
      const aiResponse = await this.callProvider(selectedProvider, enhancedPrompt, context);
      
      // NO CODE MODE: Filter out code blocks from responses
      if (this.showCode === false) {
        aiResponse.content = this.filterCodeBlocks(aiResponse.content);
        aiResponse.content = this.makeConversational(aiResponse.content, prompt);
      }
      
      // Check if response contains code that should be saved as files
      await this.handleCodeFileGeneration(aiResponse, context);
      
      // Check if response contains code that should be executed
      const codeBlocks = this.extractCodeBlocks(aiResponse.content);
      if (codeBlocks.length > 0 && context.executeCode !== false) {
        const executionResults = await this.executeCodeBlocks(codeBlocks);
        aiResponse.executionResults = executionResults;
        
        // Append execution results to response if auto-execute is enabled
        if (this.userPreferences.autoExecute) {
          aiResponse.content += '\n\n## Execution Results\n\n' + 
            executionResults.map(r => `**Output:** \`${r.output}\``).join('\n');
        }
      }
      
      return aiResponse;
    } catch (error) {
      console.error(`Provider ${selectedProvider} failed:`, error.message);
      return await this.fallbackGenerate(prompt, context);
    }
  }

  async triggerMaintenanceTask(task, options = {}) {
    switch (task) {
      case 'inspection': {
        const report = await this.selfInspection.runInspection({ trigger: 'api', ...options });
        return {
          type: 'inspection',
          status: 'completed',
          report
        };
      }
      case 'tests': {
        const session = await this.changeOrchestrator.startSession({
          prompt: 'Run automated tests',
          description: 'Maintenance: Vitest suite',
          metadata: { task: 'tests', trigger: 'maintenance-api' }
        });

        try {
          const validation = await this.changeOrchestrator.runValidation(
            session.id,
            options.command || 'npm run test -- --run',
            {
              cwd: options.cwd || path.join(process.cwd(), 'web-app'),
              timeout: options.timeout ?? 240000,
              maxBuffer: options.maxBuffer ?? 1024 * 1024 * 10
            }
          );

          const summary = await this.changeOrchestrator.finalizeSession(session.id, 'completed', {
            validations: [validation],
            triggeredBy: 'maintenance-tests'
          });

          return {
            type: 'tests',
            status: 'completed',
            sessionId: session.id,
            validation,
            session: summary
          };
        } catch (error) {
          await this.changeOrchestrator.finalizeSession(session.id, 'failed', {
            error: error.message,
            triggeredBy: 'maintenance-tests'
          });
          error.sessionId = session.id;
          throw error;
        }
      }
      default:
        throw new Error(`Unsupported maintenance task: ${task}`);
    }
  }

  listRecentChangeSessions(limit = 10) {
    if (!this.changeOrchestrator) {
      return [];
    }
    const sessions = this.changeOrchestrator.listSessions();
    return sessions
      .sort((a, b) => new Date(b.createdAt || 0) - new Date(a.createdAt || 0))
      .slice(0, limit);
  }

  parseFilesystemCommand(prompt) {
    const commands = {
      // Self-awareness commands (prioritized for immediate access)
      'show your code': 'show-code',
      'show code': 'show-code',
      'view your code': 'show-code',
      'view code': 'show-code',
      'read your code': 'show-code',
      'modify your code': 'modify-code',
      'edit your code': 'modify-code',
      'modify code': 'modify-code',
      'edit code': 'modify-code',
      'update your code': 'modify-code',
      'search your code': 'search-code',
      'search code': 'search-code',
      'find in code': 'search-code',
      'analyze your code': 'analyze-code',
      'analyze code': 'analyze-code',
      'understand code': 'analyze-code',
      'code stats': 'analyze-code',
      'code structure': 'code-structure',
      'project structure': 'code-structure',
      
      // RAPID SELF-MODIFICATION COMMANDS
      'add capability': 'self-add-capability',
      'add new capability': 'self-add-capability',
      'add feature': 'self-add-feature',
      'create feature': 'self-add-feature',
      'patch method': 'self-patch-method',
      'modify method': 'self-patch-method',
      'hot reload': 'self-hot-reload',
      'reload module': 'self-hot-reload',
      'restart yourself': 'self-restart',
      'restart server': 'self-restart',
      'enhance yourself': 'self-enhance',
      'improve yourself': 'self-enhance',
      'optimize yourself': 'self-optimize',
      'upgrade yourself': 'self-upgrade',
      'change yourself': 'self-modify',
      'modify yourself': 'self-modify',
      'update yourself': 'self-update',
      // Standard filesystem commands
      'list files': 'list',
      'show files': 'list',
      'ls': 'list',
      'create project': 'create-project',
      'new project': 'create-project',
      'read file': 'read',
      'open file': 'read',
      'view file': 'read',
      'show file': 'read',
      'save file': 'write',
      'write file': 'write',
      'save to': 'write',
      'write to': 'write',
      'create file': 'write',
      'append to': 'append',
      'delete file': 'delete',
      'remove file': 'delete',
      'search files': 'search',
      'find in files': 'search',
      'workspace summary': 'summary',
      'update code': 'modify-code',
      'search your code': 'search-code',
      'search code': 'search-code',
      'analyze your code': 'analyze-code',
      'analyze code': 'analyze-code',
      'how do you work': 'analyze-code',
      'show your structure': 'code-structure',
      'show code structure': 'code-structure',
      'code structure': 'code-structure',
      // Capability/awareness intents
      'self aware': 'capabilities',
      'self-aware': 'capabilities',
      'self awareness': 'capabilities',
      'self-awareness': 'capabilities',
      'can you see your files': 'capabilities',
      'see your files': 'capabilities',
      'access your files': 'capabilities',
      'filesystem access': 'capabilities',
      'can you access your code': 'capabilities',
  'access your code': 'capabilities'
      ,
      // Self-inspection intents
      'inspect repository': 'inspect',
      'inspect repo': 'inspect',
      'check repository health': 'inspect',
      'check health': 'inspect',
      'run inspection': 'inspect',
      'analyze repository': 'inspect',
      'should i inspect': 'should-inspect',
      'inspection needed': 'should-inspect',
      'check if inspection needed': 'should-inspect',
      'inspection status': 'inspection-status',
      'last inspection': 'inspection-status',
      'cleanup repository': 'cleanup',
      'clean repo': 'cleanup',
      'remove duplicates': 'cleanup',
      'remove backup files': 'cleanup',
      // System management intents
      'security': 'improve-security',
      'harden': 'improve-security',
      'rate limit': 'improve-security',
      'helmet': 'improve-security',
      'secure': 'improve-security',
      'ddos': 'improve-security',
      'csrf': 'improve-security',
      'xss': 'improve-security',
      'migrate': 'cloud-migration',
      'cloud': 'cloud-migration',
      'deploy': 'cloud-migration',
      'server': 'cloud-migration',
      'production': 'cloud-migration'
    };

    const lowerPrompt = prompt.toLowerCase();
    for (const [trigger, command] of Object.entries(commands)) {
      if (lowerPrompt.includes(trigger)) {
        return { command, originalPrompt: prompt };
      }
    }
    // Regex-based intents for more natural phrasing and minor typos
    const patterns = [
      { re: /can you\s+(see|access|browse).*?(file\s*system|filesystem|files?)/i, command: 'capabilities' },
      { re: /(add|enable|setup).*(security|helmet|rate\s*limit|csrf|xss|ddos)/i, command: 'improve-security' },
      { re: /(migrate|move|deploy|host).*(cloud|cloude|server|prod|production)/i, command: 'cloud-migration' }
    ];
    for (const { re, command } of patterns) {
      if (re.test(prompt)) return { command, originalPrompt: prompt };
    }
    return null;
  }

  // UI Generation Request Parsing
  parseUIRequest(prompt) {
    const uiKeywords = [
      'create ui', 'make ui', 'generate ui', 'build ui', 'design ui',
      'create interface', 'make interface', 'generate interface', 'build interface',
      'create form', 'make form', 'generate form', 'build form',
      'create dashboard', 'make dashboard', 'generate dashboard', 'build dashboard',
      'create page', 'make page', 'generate page', 'build page',
      'create component', 'make component', 'generate component', 'build component'
    ];

    const lowerPrompt = prompt.toLowerCase();
    
    // Check for UI generation keywords
    const hasUIKeyword = uiKeywords.some(keyword => lowerPrompt.includes(keyword));
    
    if (hasUIKeyword) {
      const uiType = this.detectUIType(prompt);
      const components = this.suggestComponents(prompt);
      
      return {
        isUIRequest: true,
        type: uiType,
        components: components,
        originalPrompt: prompt
      };
    }
    
    return { isUIRequest: false };
  }

  detectUIType(prompt) {
    const lowerPrompt = prompt.toLowerCase();
    
    if (lowerPrompt.includes('dashboard')) return 'dashboard';
    if (lowerPrompt.includes('form')) return 'form';
    if (lowerPrompt.includes('calculator')) return 'calculator';
    if (lowerPrompt.includes('todo') || lowerPrompt.includes('task')) return 'todo-app';
    if (lowerPrompt.includes('chat') || lowerPrompt.includes('messaging')) return 'chat-interface';
    if (lowerPrompt.includes('chart') || lowerPrompt.includes('graph')) return 'data-visualization';
    if (lowerPrompt.includes('login') || lowerPrompt.includes('signup')) return 'auth-form';
    if (lowerPrompt.includes('profile') || lowerPrompt.includes('user')) return 'user-profile';
    if (lowerPrompt.includes('game')) return 'game-interface';
    if (lowerPrompt.includes('quiz') || lowerPrompt.includes('test')) return 'quiz-app';
    
    return 'general-interface';
  }

  suggestComponents(prompt) {
    const lowerPrompt = prompt.toLowerCase();
    const components = [];
    
    // Form components
    if (lowerPrompt.includes('input') || lowerPrompt.includes('field')) components.push('input-field');
    if (lowerPrompt.includes('button')) components.push('button');
    if (lowerPrompt.includes('dropdown') || lowerPrompt.includes('select')) components.push('dropdown');
    if (lowerPrompt.includes('checkbox')) components.push('checkbox');
    if (lowerPrompt.includes('radio')) components.push('radio-button');
    if (lowerPrompt.includes('slider')) components.push('range-slider');
    
    // Display components
    if (lowerPrompt.includes('table') || lowerPrompt.includes('grid')) components.push('data-table');
    if (lowerPrompt.includes('card')) components.push('card');
    if (lowerPrompt.includes('list')) components.push('list');
    if (lowerPrompt.includes('modal') || lowerPrompt.includes('popup')) components.push('modal');
    if (lowerPrompt.includes('tab')) components.push('tabs');
    if (lowerPrompt.includes('progress')) components.push('progress-bar');
    
    // Chart components
    if (lowerPrompt.includes('chart') || lowerPrompt.includes('graph')) {
      if (lowerPrompt.includes('bar')) components.push('bar-chart');
      if (lowerPrompt.includes('line')) components.push('line-chart');
      if (lowerPrompt.includes('pie')) components.push('pie-chart');
      if (lowerPrompt.includes('scatter')) components.push('scatter-plot');
    }
    
    // Navigation components
    if (lowerPrompt.includes('menu') || lowerPrompt.includes('nav')) components.push('navigation');
    if (lowerPrompt.includes('sidebar')) components.push('sidebar');
    if (lowerPrompt.includes('header')) components.push('header');
    if (lowerPrompt.includes('footer')) components.push('footer');
    
    return components.length > 0 ? components : ['basic-container', 'text-display'];
  }

  async handleUIRequest(uiRequest, prompt) {
    try {
      console.log(`üé® Handling UI generation request: ${uiRequest.type}`);
      
      // Generate UI using the UI generator
      const ToolooUIGenerator = require('./tooloo-ui-generator.js');
      const uiGenerator = new ToolooUIGenerator();
      
      const generatedUI = uiGenerator.generateInterface({
        type: uiRequest.type,
        components: uiRequest.components.map(comp => ({ type: comp })),
        title: `${uiRequest.type} Interface`,
        subtitle: 'Generated by TooLoo AI'
      });
      
      return {
        success: true,
        type: 'ui-generation',
        content: generatedUI,
        metadata: {
          uiType: uiRequest.type,
          components: uiRequest.components,
          timestamp: new Date().toISOString()
        }
      };
    } catch (error) {
      console.error('‚ùå UI generation error:', error);
      return {
        success: false,
        error: error.message,
        fallback: 'I can help you create UIs! Try asking me to "create a dashboard" or "make a form interface".'
      };
    }
  }

  async handleFilesystemCommand(fsCommand, prompt) {
    try {
      switch (fsCommand.command) {
        case 'capabilities':
          {
            const summary = await this.filesystemManager.getWorkspaceSummary().catch(() => null);
            const workspaceText = summary ? `\n\n### Workspace\n- Path: \`${summary.workspace.path}\`\n- Projects: ${summary.projects.count}\n- Files: ${summary.projects.files}` : '';
            return {
              content: `## ‚úÖ Yes ‚Äî I can see and manage my own file system\n\nSelf-awareness is enabled by default. I can list, read, write, and modify files within this workspace.${workspaceText}\n\nYou can ask me to:\n- list files\n- create project <name>\n- write file <path> with content ...\n- search files for \"TODO\"\n- improve security\n- migrate to a cloud server`,
              provider: 'self-awareness',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }
        case 'list':
          const listing = await this.filesystemManager.listDirectory();
          return {
            content: `## üìÅ Files in your workspace:\n\n${this.formatDirectoryListing(listing)}`,
            provider: 'filesystem',
            cost: 0,
            tokens: { input: 0, output: 0 }
          };

        case 'create-project':
          const projectName = this.extractProjectName(prompt);
          const project = await this.filesystemManager.createProject(projectName, 'Created by TooLoo.ai');
          return {
            content: `## üéâ Project Created!\n\n**Project:** ${projectName}\n**Path:** \`${project.projectPath}\`\n\nReady to start building! What would you like to create in this project?`,
            provider: 'filesystem',
            cost: 0,
            tokens: { input: 0, output: 0 }
          };

        case 'summary':
          const summary = await this.filesystemManager.getWorkspaceSummary();
          return {
            content: `## üìä Workspace Summary\n\n**Workspace:** \`${summary.workspace.path}\`\n**Projects:** ${summary.projects.count} projects, ${summary.projects.files} files\n\n**Supported file types:** ${summary.allowedExtensions.join(', ')}\n\nWhat would you like to build today?`,
            provider: 'filesystem',
            cost: 0,
            tokens: { input: 0, output: 0 }
          };

        case 'write':
          const writeInfo = this.parseWriteFileCommand(prompt);
          if (!writeInfo.filePath) {
            return {
              content: `## ‚ùå Invalid Write Command\n\nPlease specify file path. Examples:\n- "write file project/index.html with content <html>...</html>"\n- "save file app.js with console.log('hello');"`,
              provider: 'filesystem',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }
          
          const fullPath = path.join(this.filesystemManager.projectsDir, writeInfo.filePath);
          await this.filesystemManager.writeFile(fullPath, writeInfo.content || '// File created by TooLoo.ai\n');
          
          return {
            content: `## ‚úÖ File Created!\n\n**File:** \`${writeInfo.filePath}\`\n**Path:** \`${fullPath}\`\n**Size:** ${(writeInfo.content || '').length} characters\n\nFile saved successfully! What's next?`,
            provider: 'filesystem',
            cost: 0,
            tokens: { input: 0, output: 0 }
          };

        case 'read':
          const readPath = this.extractFilePath(prompt);
          if (!readPath) {
            return {
              content: `## ‚ùå Invalid Read Command\n\nPlease specify file path. Example: "read file project/index.html"`,
              provider: 'filesystem',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }
          
          const fullReadPath = path.join(this.filesystemManager.projectsDir, readPath);
          const fileResult = await this.filesystemManager.readFile(fullReadPath);
          
          return {
            content: `## üìÑ File Content: \`${readPath}\`\n\n\`\`\`\n${fileResult.content}\n\`\`\`\n\n**Size:** ${fileResult.size} bytes`,
            provider: 'filesystem',
            cost: 0,
            tokens: { input: 0, output: 0 }
          };

        case 'delete':
          {
            const fileToDelete = this.extractFilePath(prompt) || prompt.replace(/.*delete\s+file\s+/i, '').trim();
            if (!fileToDelete) {
              return {
                content: `## ‚ùå Invalid Delete Command\n\nPlease specify file path. Example: "delete file project/index.html"`,
                provider: 'filesystem',
                cost: 0,
                tokens: { input: 0, output: 0 }
              };
            }
            const fullDelPath = path.join(this.filesystemManager.projectsDir, fileToDelete);
            const delRes = await this.filesystemManager.deleteItem(fullDelPath, { recursive: false });
            return {
              content: `## üóëÔ∏è Deleted\n\n**Path:** \`${delRes.path || fullDelPath}\``,
              provider: 'filesystem',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }

        case 'search':
          {
            // Look for quoted term or after 'search files for'
            const m = prompt.match(/search\s+files\s+(?:for\s+)?"([^"]+)"/i) || prompt.match(/search\s+files\s+(?:for\s+)?'([^']+)'/i) || prompt.match(/search\s+files\s+(?:for\s+)?(\S+)/i);
            const term = m ? m[1] || m[0].split(/\s+/).pop() : null;
            if (!term) {
              return {
                content: `## ‚ùå Invalid Search Command\n\nSpecify a term. Example: "search files for \"TODO\""`,
                provider: 'filesystem',
                cost: 0,
                tokens: { input: 0, output: 0 }
              };
            }
            const results = await this.filesystemManager.searchFiles(term);
            const lines = results.results.slice(0, 50).map(r => `- \`${r.file}\` (${r.matches} matches)`).join('\n') || '*No matches*';
            return {
              content: `## üîé Search Results for \`${term}\`\n\n${lines}\n\n_Total matches:_ ${results.totalMatches}`,
              provider: 'filesystem',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }

        case 'append':
          {
            const writeInfo = this.parseWriteFileCommand(prompt);
            if (!writeInfo.filePath) {
              return {
                content: `## ‚ùå Invalid Append Command\n\nPlease specify file path and content. Example: "append to app.js: console.log('more');"`,
                provider: 'filesystem',
                cost: 0,
                tokens: { input: 0, output: 0 }
              };
            }
            const fullPath = path.join(this.filesystemManager.projectsDir, writeInfo.filePath);
            let base = '';
            try {
              const existing = await this.filesystemManager.readFile(fullPath);
              base = existing.content;
              if (base && !base.endsWith('\n')) base += '\n';
            } catch (e) {
              // If file doesn't exist, we'll create it fresh
            }
            const newContent = base + (writeInfo.content || '');
            await this.filesystemManager.writeFile(fullPath, newContent);
            return {
              content: `## ‚ûï Content Appended\n\n**File:** \`${writeInfo.filePath}\`\n**Path:** \`${fullPath}\`\n**Added:** ${writeInfo.content.length} characters`,
              provider: 'filesystem',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }
          
        // Self-awareness commands
        case 'show-code':
          {
            // Extract file path from prompts like "show your code simple-api-server.js"
            const codeMatch = prompt.match(/(?:show|view|read).*code\s+([^\s]+)/i);
            const filePath = codeMatch ? codeMatch[1] : 'simple-api-server.js'; // Default to main file
            
            const result = await this.selfAwarenessManager.getSourceCode(filePath);
            
            if (!result.success) {
              return {
                content: `## ‚ùå Error Reading Code\n\n${result.error}`,
                provider: 'self-awareness',
                cost: 0,
                tokens: { input: 0, output: 0 }
              };
            }
            
            return {
              content: `## üìÑ Source Code: \`${filePath}\`\n\n\`\`\`javascript\n${result.content}\n\`\`\`\n\n**Size:** ${result.size} bytes`,
              provider: 'self-awareness',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }
          
        case 'modify-code':
          {
            // Extract file path and code from prompt
            // Format: modify your code file.js: new content
            const modifyMatch = prompt.match(/(?:modify|edit|update).*code\s+([^\s:]+)(?:\s*:\s*|\s+with\s+)([\s\S]+)/i);
            
            if (!modifyMatch) {
              return {
                content: `## ‚ùå Invalid Code Modification\n\nPlease use format: "modify your code file.js: new content"`,
                provider: 'self-awareness',
                cost: 0,
                tokens: { input: 0, output: 0 }
              };
            }
            
            const filePath = modifyMatch[1];
            const newContent = modifyMatch[2].trim();
            
            // Backup original and update
            const result = await this.selfAwarenessManager.modifySourceCode(filePath, newContent, { backup: true });
            
            if (!result.success) {
              return {
                content: `## ‚ùå Failed to Modify Code\n\n${result.error}`,
                provider: 'self-awareness',
                cost: 0,
                tokens: { input: 0, output: 0 }
              };
            }
            
            return {
              content: `## ‚úÖ Code Modified Successfully\n\n**File:** \`${filePath}\`\n\nA backup was created before modifications. The changes will take effect when the server is restarted.`,
              provider: 'self-awareness',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }
          
        case 'search-code':
          {
            // Extract search term from "search your code for X"
            const searchMatch = prompt.match(/search.*code(?:\s+for)?\s+["']?([^"']+)["']?/i);
            
            if (!searchMatch) {
              return {
                content: `## ‚ùå Invalid Code Search\n\nPlease specify what to search for. Example: "search your code for handleFilesystemCommand"`,
                provider: 'self-awareness',
                cost: 0,
                tokens: { input: 0, output: 0 }
              };
            }
            
            const term = searchMatch[1].trim();
            const results = await this.selfAwarenessManager.searchCodebase(term);
            
            if (results.totalMatches === 0) {
              return {
                content: `## üîç No matches found for "${term}" in the codebase.`,
                provider: 'self-awareness',
                cost: 0,
                tokens: { input: 0, output: 0 }
              };
            }
            
            // Format results
            let formattedResults = results.results.slice(0, 5).map(file => {
              const matchSummary = file.matches.slice(0, 3).map(match => {
                return `Line ${match.line}: \`${match.text}\``;
              }).join('\n');
              
              return `**File:** \`${file.file}\` (${file.matchCount} matches)\n${matchSummary}${file.matches.length > 3 ? '\n...and more' : ''}`;
            }).join('\n\n');
            
            if (results.results.length > 5) {
              formattedResults += `\n\n...and ${results.results.length - 5} more files with matches`;
            }
            
            return {
              content: `## üîç Code Search Results for "${term}"\n\nFound ${results.totalMatches} matches in ${results.matchingFiles} files.\n\n${formattedResults}`,
              provider: 'self-awareness',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }
          
        case 'analyze-code':
          {
            // Extract file path from prompt or analyze the whole codebase
            const fileMatch = prompt.match(/analyze.*code\s+([^\s]+)/i);
            const filePath = fileMatch ? fileMatch[1] : null;
            
            const analysis = await this.selfAwarenessManager.analyzeCode(filePath);
            
            let content = '';
            
            if (filePath && analysis.success) {
              // Single file analysis
              content = `## üîç Code Analysis: \`${filePath}\`\n\n` +
                        `**Lines:** ${analysis.stats.lines}\n` +
                        `**Size:** ${analysis.stats.size} bytes\n` +
                        `**Functions:** ${analysis.stats.functions}\n` +
                        `**Imports:** ${analysis.stats.imports.join(', ') || 'None'}\n`;
            } else if (!filePath) {
              // Whole codebase analysis
              content = `## üîç Codebase Analysis\n\n` +
                        `**Total Files:** ${analysis.totalFiles}\n` +
                        `**Total Lines:** ${analysis.totalLines}\n` +
                        `**Total Size:** ${(analysis.totalSize / 1024).toFixed(2)} KB\n\n` +
                        `**File Types:**\n` +
                        Object.entries(analysis.fileTypes)
                          .map(([ext, stats]) => `- ${ext || 'no extension'}: ${stats.count} files, ${stats.lines} lines`)
                          .join('\n') + 
                        `\n\n**Largest Files:**\n` +
                        analysis.largestFiles.slice(0, 5)
                          .map(f => `- ${f.path}: ${f.lines} lines, ${(f.size / 1024).toFixed(2)} KB`)
                          .join('\n');
            } else {
              content = `## ‚ùå Failed to analyze ${filePath}\n\n${analysis.error}`;
            }
            
            return {
              content,
              provider: 'self-awareness',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }
          
        case 'code-structure':
          {
            // Get project structure with specified depth
            const depthMatch = prompt.match(/(?:structure|hierarchy).*(?:depth|level)\s+(\d+)/i);
            const depth = depthMatch ? parseInt(depthMatch[1]) : 2;
            
            const structure = await this.selfAwarenessManager.getProjectStructure(depth);
            
            // Helper function to format structure recursively
            const formatStructure = (node, indent = '') => {
              if (!node) return '';
              
              let output = `${indent}${node.type === 'directory' ? 'üìÅ' : 'üìÑ'} **${node.name}**\n`;
              
              if (node.children && node.type === 'directory') {
                node.children
                  .sort((a, b) => (a.type === 'directory' ? 0 : 1) - (b.type === 'directory' ? 0 : 1))
                  .forEach(child => {
                    output += formatStructure(child, indent + '  ');
                  });
              }
              
              return output;
            };
            
            const formattedStructure = formatStructure(structure);
            
            return {
              content: `## üìä TooLoo.ai Code Structure\n\n${formattedStructure}`,
              provider: 'self-awareness',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }

        case 'improve-security':
          {
            // Lightweight introspection to confirm middleware presence
            let securityEnabled = false;
            try {
              const serverFile = await this.filesystemManager.readFile(path.join(this.filesystemManager.workspaceRoot, 'simple-api-server.js'));
              securityEnabled = serverFile.content.includes("require('helmet')") && serverFile.content.includes('rateLimit(');
const simplehelloworldManager = require('./simple-hello-world');
            } catch {}

            const steps = [
              '- Enabled HTTP security headers with helmet()',
              '- Added API rate limiting to prevent abuse',
              '- Kept CORS open for dev; can be restricted via env in production',
            ];

            return {
              content: `## ‚úÖ Security Hardening${securityEnabled ? ' (active)' : ''}\n\nI have security middleware wired by default.\n\nWhat I did / can do for you now:\n${steps.map(s => `* ${s}`).join('\n')}\n\nYou can tune limits via env: RATE_LIMIT_WINDOW_MS, RATE_LIMIT_MAX.\n\nAsk me to: "restrict CORS to your domain" or "enable CSP" for production.`,
              provider: 'system-management',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }

        case 'cloud-migration':
          {
            // Provide a concrete plan and scaffold CI for container publish
            // Create GitHub Actions workflow and a deploy guide if missing
            const workflowPath = path.join(this.filesystemManager.workspaceRoot, '.github', 'workflows', 'docker-publish.yml');
            const deployReadmePath = path.join(this.filesystemManager.workspaceRoot, 'deploy', 'README.md');
            try {
              // Ensure directories and write files
              const workflowContent = `name: Build and Publish Docker Image\n\n'on':\n  push:\n    branches: [ 'main' ]\n  workflow_dispatch: {}\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      - name: Log in to GHCR\n        uses: docker/login-action@v3\n        with:\n          registry: ghcr.io\n          username: \${{ github.actor }}\n          password: \${{ secrets.GITHUB_TOKEN }}\n      - name: Extract metadata (tags, labels)\n        id: meta\n        uses: docker/metadata-action@v5\n        with:\n          images: ghcr.io/\${{ github.repository }}\n      - name: Build and push\n        uses: docker/build-push-action@v5\n        with:\n          context: .\n          push: true\n          tags: \${{ steps.meta.outputs.tags }}\n          labels: \${{ steps.meta.outputs.labels }}\n`;
              await this.filesystemManager.writeFile(workflowPath, workflowContent);

              const deployGuide = `# Cloud Deployment Guide\n\nThis repo is container-ready. A GitHub Actions workflow is included to build and publish images to GHCR.\n\n## Steps\n1. Enable GitHub Packages for your repo (GHCR).\n2. Merge to main; the workflow will build and push: ghcr.io/OWNER/REPO:latest.\n3. Provision a small VM or use a PaaS (Render, Fly.io, Railway, Koyeb).\n4. Run the container with:\n\n   docker run -p 3001:3001 ghcr.io/OWNER/REPO:latest\n\n5. Set env vars as needed (PORT=3001, provider API keys).\n\nFor Render/Fly, create a service pointing to the GHCR image.\n`;
              await this.filesystemManager.writeFile(deployReadmePath, deployGuide);
            } catch {}

            return {
              content: `## ‚òÅÔ∏è Cloud Migration Plan\n\nI can migrate myself by containerizing (already supported) and publishing to a registry. I've scaffolded CI to build/push to GHCR on pushes to main, and added a deploy guide.\n\nNext steps I can perform:\n- Configure environment variables for prod\n- Add health checks and port config (already present)\n- Optional: tighten CORS to your domain\n\nProvide your target (Render/Fly/DigitalOcean). I can generate specific configs on request.`,
              provider: 'system-management',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }

        // RAPID SELF-MODIFICATION COMMANDS
        case 'self-add-capability':
          return await this.handleSelfModification('addCapability', prompt);

        case 'self-add-feature':
          return await this.handleSelfModification('createFeature', prompt);

        case 'self-patch-method':
          return await this.handleSelfModification('patchMethod', prompt);

        case 'self-hot-reload':
          return await this.handleSelfModification('hotReload', prompt);

        case 'self-restart':
          return await this.handleSelfModification('restart', prompt);

        case 'self-enhance':
        case 'self-optimize':
        case 'self-upgrade':
        case 'self-modify':
        case 'self-update':
          return await this.handleSelfModification('enhance', prompt);

        default:
          return {
            content: `## üìÅ Filesystem Commands\n\n- list files | ls ‚Äî Show workspace contents\n- create project [name] ‚Äî Create a new project\n- workspace summary ‚Äî Show workspace overview\n- read file [path] ‚Äî View a file\n- write file [path] with content ... ‚Äî Create/overwrite a file\n- append to [path]: ... ‚Äî Append content to a file\n- delete file [path] ‚Äî Delete a file\n- search files for "term" ‚Äî Find text across files\n\nExamples:\n- write file MyApp/index.html with content <html>...</html>\n- append to MyApp/app.js: console.log('Hi');\n- read file MyApp/index.html\n- search files for "TODO"\n\nWhat would you like to do?`,
            provider: 'filesystem',
            cost: 0,
            tokens: { input: 0, output: 0 }
          };
      }
    } catch (error) {
      return {
        content: `## ‚ùå Filesystem Error\n\n${error.message}\n\nTry a different command or ask for help with filesystem operations.`,
        provider: 'filesystem',
        cost: 0,
        tokens: { input: 0, output: 0 }
      };
    }
  }

  async enhancePromptWithContext(prompt, context) {
    // If user is asking to build something, provide filesystem context
    const buildKeywords = ['create', 'build', 'make', 'generate', 'write', 'develop'];
    const hasBuildIntent = buildKeywords.some(keyword => prompt.toLowerCase().includes(keyword));
    
    if (hasBuildIntent) {
      try {
        const summary = await this.filesystemManager.getWorkspaceSummary();
        const contextInfo = `\n\n[SYSTEM CONTEXT: You have full filesystem access. Current workspace has ${summary.projects.count} projects. You can create files, organize projects, and build complete applications. When generating code, consider suggesting file organization and project structure.]`;
        return prompt + contextInfo;
      } catch (error) {
        return prompt;
      }
    }
    
    return prompt;
  }

  async handleCodeFileGeneration(aiResponse, context) {
    // If the AI response contains file suggestions and user wants to save them
    if (context.autoSaveFiles && aiResponse.content.includes('```')) {
      const codeBlocks = this.extractCodeBlocks(aiResponse.content);
      const savedFiles = [];

      for (const block of codeBlocks) {
        try {
          // Try to determine filename from context or generate one
          const filename = this.generateFilename(block, context);
          if (filename) {
            await this.filesystemManager.writeFile(filename, block.code);
            savedFiles.push(filename);
          }
        } catch (error) {
          console.warn('Could not auto-save file:', error.message);
        }
      }

      if (savedFiles.length > 0) {
        aiResponse.content += `\n\n## üíæ Files automatically saved:\n${savedFiles.map(f => `- \`${f}\``).join('\n')}`;
      }
    }
  }

  formatDirectoryListing(listing) {
    if (!listing.items || listing.items.length === 0) {
      return '*No files found. Ready to create your first project!*';
    }

    return listing.items
      .map(item => {
        const icon = item.isDirectory ? 'üìÅ' : 'üìÑ';
        const size = item.isFile ? ` (${Math.round(item.size / 1024)}KB)` : '';
        return `${icon} **${item.name}**${size}`;
      })
      .join('\n');
  }

  extractProjectName(prompt) {
    // Extract project name from prompts like "create project my-app" 
    const match = prompt.match(/(?:create|new)\s+project\s+([a-zA-Z0-9-_\s]+)/i);
    return match ? match[1].trim() : `project-${Date.now()}`;
  }

  parseWriteFileCommand(prompt) {
    // Accept forms:
    // - "write file path/file.js with content ..."
    // - "save file path/file.js ..."
    // - "create file path/file.js ..."
    // - "save to path/file.js: ..."
    // - "write to path/file.js: ..."
    // - with code blocks ```...
    let m = prompt.match(/(?:write|save|create)\s+file\s+([^\s:]+)(?:\s+with\s+(?:content\s+)?([\s\S]+))?$/i);
    if (!m) m = prompt.match(/(?:write|save)\s+to\s+([^\s:]+)\s*:\s*([\s\S]+)$/i);
    if (!m) {
      // Try to capture path then a fenced code block
      const pathMatch = prompt.match(/(?:file|to)\s+([^\s:]+).*?```[\s\S]*?```/i);
      if (pathMatch) {
        const codeMatch = prompt.match(/```[\w-]*\n([\s\S]*?)```/);
        return { filePath: pathMatch[1], content: codeMatch ? codeMatch[1] : '' };
      }
    }
    if (m) {
      return { filePath: m[1], content: (m[2] || '').trim() };
    }
    return { filePath: null, content: '' };
  }

  extractFilePath(prompt) {
    // Extract file path from prompts like "read file project/index.html" or "open file ..."
    const match = prompt.match(/(?:read|show|open|view)\s+file\s+([^\s]+)/i);
    return match ? match[1] : null;
  }

  generateFilename(codeBlock, context) {
    const extensions = {
      'javascript': '.js',
      'typescript': '.ts', 
      'jsx': '.jsx',
      'tsx': '.tsx',
      'python': '.py',
      'html': '.html',
      'css': '.css',
      'json': '.json'
    };

    if (context.projectName && codeBlock.language) {
      const ext = extensions[codeBlock.language] || '.txt';
      return `./personal-projects/${context.projectName}/index${ext}`;
    }
    
    return null;
  }

  extractCodeBlocks(text) {
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    const blocks = [];
    let match;

    while ((match = codeBlockRegex.exec(text)) !== null) {
      const language = match[1] || 'javascript';
      const code = match[2].trim();
      
      // Only execute safe languages for personal use
      if (['javascript', 'js'].includes(language.toLowerCase())) {
        blocks.push({ language, code });
      }
    }

    return blocks;
  }

  async executeCodeBlocks(codeBlocks) {
    const results = [];
    
    for (const block of codeBlocks) {
      try {
        const result = await this.codeExecutor.execute(block.code, block.language);
        results.push({
          code: block.code,
          language: block.language,
          ...result
        });
      } catch (error) {
        results.push({
          code: block.code,
          language: block.language,
          success: false,
          error: error.message,
          output: ''
        });
      }
    }
    
    return results;
  }

  selectBestProvider(prompt, context) {
    // Smart routing based on prompt characteristics
    if (prompt.toLowerCase().includes('code') || prompt.toLowerCase().includes('function')) {
      return this.providers.has('deepseek') ? 'deepseek' : 'openai';
    }
    
    if (prompt.length > 2000) {
      return this.providers.has('claude') ? 'claude' : 'openai';
    }

    // Default to cost-effective option
    return this.providers.has('deepseek') ? 'deepseek' : 'huggingface';
  }

  /**
   * Filter out code blocks from response (NO CODE MODE!)
   */
  filterCodeBlocks(content) {
    if (!content) return content;
    
    // Remove code blocks (```...```)
    let filtered = content.replace(/```[\s\S]*?```/g, '‚úÖ *Code executed and saved*');
    
    // Remove inline code that looks like file paths or commands
    filtered = filtered.replace(/`[^`]{20,}`/g, 'üìÑ *file content*');
    
    return filtered;
  }

  /**
   * Make response more conversational and action-focused
   */
  makeConversational(content, originalPrompt) {
    // Add friendly intro if it doesn't have one
    if (!content.match(/^(##|Sure|Great|I'll|Let me|I've|‚úÖ)/)) {
      content = `‚úÖ **Done!** ${content}`;
    }
    
    // Replace technical terms with friendly ones
    content = content.replace(/executed/gi, 'ran');
    content = content.replace(/implemented/gi, 'built');
    content = content.replace(/initialized/gi, 'set up');
    content = content.replace(/terminated/gi, 'stopped');
    
    // Add encouraging endings
    if (!content.includes('ready') && !content.includes('complete')) {
      content += '\n\n‚ú® **Ready to go!** What\'s next?';
    }
    
    return content;
  }

  /**
   * Extract code blocks from content
   */
  extractCodeBlocks(content) {
    if (!content) return [];
    
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    const blocks = [];
    let match;
    
    while ((match = codeBlockRegex.exec(content)) !== null) {
      blocks.push({
        language: match[1] || 'javascript',
        code: match[2].trim()
      });
    }
    
    return blocks;
  }

  async callProvider(providerName, prompt, context) {
    const provider = this.providers.get(providerName);
    if (!provider) throw new Error(`Provider ${providerName} not available`);

    // Simplified provider calls - expand based on your needs
    switch (providerName) {
      case 'huggingface':
        return await this.callHuggingFace(provider, prompt);
      case 'deepseek':
        return await this.callDeepSeek(provider, prompt);
      case 'openai':
        return await this.callOpenAI(provider, prompt);
      default:
        throw new Error(`Provider ${providerName} not implemented yet`);
    }
  }

  async callHuggingFace(provider, prompt) {
    // Free tier implementation with timeout
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 30000); // 30 second timeout
    
    try {
      const response = await fetch(provider.endpoint, {
        method: 'POST',
        headers: {
          ...provider.headers,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          inputs: prompt,
          parameters: { max_length: 1000, temperature: 0.7 }
        }),
        signal: controller.signal
      });

      clearTimeout(timeout);

      if (!response.ok) {
        throw new Error(`HuggingFace API error: ${response.status}`);
      }

      const result = await response.json();
      return {
        content: Array.isArray(result) ? result[0]?.generated_text || 'No response' : result.generated_text || 'No response',
        provider: 'huggingface',
        cost: 0,
        tokens: { input: prompt.length, output: 100 } // Estimate
      };
    } catch (error) {
      clearTimeout(timeout);
      if (error.name === 'AbortError') {
        throw new Error('HuggingFace API timeout - request took too long');
      }
      throw error;
    }
  }

  async callDeepSeek(provider, prompt) {
    // DeepSeek implementation with timeout
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 30000); // 30 second timeout
    
    try {
      const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${provider.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'deepseek-coder',
          messages: [
            { role: 'system', content: 'You are TooLoo.ai, a personal AI development assistant. Help the user build applications by generating working code and providing clear explanations.' },
            { role: 'user', content: prompt }
          ],
          temperature: 0.3,
          max_tokens: 2000
        }),
        signal: controller.signal
      });

      clearTimeout(timeout);

      if (!response.ok) {
        throw new Error(`DeepSeek API error: ${response.status}`);
      }

      const result = await response.json();
      return {
        content: result.choices[0]?.message?.content || 'No response',
        provider: 'deepseek',
        cost: (result.usage?.total_tokens || 0) * 0.00014,
        tokens: result.usage
      };
    } catch (error) {
      clearTimeout(timeout);
      if (error.name === 'AbortError') {
        throw new Error('DeepSeek API timeout - request took too long');
      }
      throw error;
    }
  }

  async callOpenAI(provider, prompt) {
    // OpenAI implementation with timeout
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 30000); // 30 second timeout
    
    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${provider.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'gpt-4-turbo-preview',
          messages: [
            { role: 'system', content: 'You are TooLoo.ai, a personal AI development assistant focused on helping non-coders build applications. Always provide working code with clear explanations.' },
            { role: 'user', content: prompt }
          ],
          temperature: 0.7,
          max_tokens: 3000
        }),
        signal: controller.signal
      });

      clearTimeout(timeout);

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
      }

      const result = await response.json();
      return {
        content: result.choices[0]?.message?.content || 'No response',
        provider: 'openai',
        cost: (result.usage?.total_tokens || 0) * 0.003, // GPT-4 pricing estimate
        tokens: result.usage
      };
    } catch (error) {
      clearTimeout(timeout);
      if (error.name === 'AbortError') {
        throw new Error('OpenAI API timeout - request took too long');
      }
      throw error;
    }
  }

  async fallbackGenerate(prompt, context) {
    // Try available providers in order of preference
    const fallbackOrder = ['huggingface', 'deepseek', 'openai', 'claude', 'gemini'];
    
    for (const providerName of fallbackOrder) {
      if (this.providers.has(providerName)) {
        try {
          return await this.callProvider(providerName, prompt, context);
        } catch (error) {
          console.warn(`Fallback ${providerName} also failed:`, error.message);
          continue;
        }
      }
    }

    throw new Error('All AI providers failed - check your API keys and network connection');
  }

  getSystemStatus() {
    const status = {
      healthy: true,
      offline: this.offline,
      providers: Array.from(this.providers.entries()).map(([name, config]) => ({
        name,
        displayName: config.name,
        enabled: config.enabled,
        hasKey: !!config.apiKey || name === 'huggingface'
      })),
      preferences: this.userPreferences
    };

    return status;
  }

  /**
   * Handle self-modification commands - TooLoo changing itself on demand!
   */
  async handleSelfModification(type, prompt) {
    try {
      console.log(`üîß Self-modification request: ${type}`);
      
      let result;
      
      switch (type) {
        case 'addCapability': {
          // Extract capability name and code from prompt
          const capabilityMatch = prompt.match(/add capability[:\s]+"([^"]+)"/i) || 
                                prompt.match(/add capability[:\s]+(\w+)/i);
          const capability = capabilityMatch ? capabilityMatch[1] : 'DynamicCapability';
          
          const codeMatch = prompt.match(/with code[:\s]+([\s\S]+)/i);
          const code = codeMatch ? codeMatch[1].trim() : `
async ${capability.toLowerCase()}(input) {
  // Auto-generated capability - customize as needed
  console.log('${capability} called with:', input);
  return { success: true, result: 'Capability executed', input };
}`;
          
          result = await this.selfAwarenessManager.addCapability(capability, code);
          break;
        }
        
        case 'createFeature': {
          const featureMatch = prompt.match(/(?:add|create) feature[:\s]+"([^"]+)"/i) || 
                             prompt.match(/(?:add|create) feature[:\s]+(\w+)/i);
          const feature = featureMatch ? featureMatch[1] : 'DynamicFeature';
          
          const codeMatch = prompt.match(/with code[:\s]+([\s\S]+)/i);
          const code = codeMatch ? codeMatch[1].trim() : `
// ${feature} - Auto-generated feature module
class ${feature.replace(/\s+/g, '')} {
  constructor() {
    this.name = '${feature}';
    this.version = '1.0.0';
  }
  
  execute(params = {}) {
    console.log('${feature} executing with params:', params);
    return { success: true, feature: this.name, result: 'Feature executed' };
  }
}`;
          
          result = await this.selfAwarenessManager.createFeatureModule(feature, code);
          break;
        }
        
        case 'patchMethod': {
          const methodMatch = prompt.match(/patch method[:\s]+"([^"]+)"/i) || 
                            prompt.match(/patch method[:\s]+(\w+)/i);
          const method = methodMatch ? methodMatch[1] : null;
          
          if (!method) {
            return {
              content: `## ‚ùå Patch Method Error\n\nPlease specify method name. Example: "patch method generateResponse with code console.log('patched!');"`,
              provider: 'self-modification',
              cost: 0,
              tokens: { input: 0, output: 0 }
            };
          }
          
          const codeMatch = prompt.match(/with code[:\s]+([\s\S]+)/i);
          const code = codeMatch ? codeMatch[1].trim() : 'console.log("Method patched!");';
          
          result = await this.selfAwarenessManager.patchMethod('simple-api-server.js', method, code, 'prepend');
          break;
        }
        
        case 'hotReload': {
          const moduleMatch = prompt.match(/(?:reload|hot.reload)[:\s]+"([^"]+)"/i) || 
                            prompt.match(/(?:reload|hot.reload)[:\s]+(\w+)/i);
          let module = moduleMatch ? moduleMatch[1] : null;
          
          if (!module) {
            result = {
              success: false,
              error: 'Please specify a module to reload. Example: "hot reload self-awareness-manager"'
            };
          } else {
            // Ensure we don't try to reload non-existent modules
            const validModules = ['self-awareness-manager', 'simple-api-server', 'personal-filesystem-manager', 'github-manager'];
            if (!validModules.includes(module)) {
              result = {
                success: false,
                error: `Module "${module}" not found. Valid modules: ${validModules.join(', ')}`
              };
            } else {
              try {
                result = await this.selfAwarenessManager.hotReloadModule(module);
              } catch (error) {
                result = {
                  success: false,
                  error: `Failed to reload ${module}: ${error.message}`
                };
              }
            }
          }
          break;
        }
        
        case 'restart': {
          result = { success: true, message: 'Server restart initiated' };
          
          // Restart after response
          setTimeout(() => {
            console.log('üîÑ TooLoo restarting itself...');
            process.exit(0);
          }, 2000);
          break;
        }
        
        case 'enhance': {
          // Intelligent self-enhancement based on prompt analysis
          const enhancements = [];
          
          if (prompt.includes('performance') || prompt.includes('optimize')) {
            enhancements.push('Performance optimization code added');
          }
          if (prompt.includes('security') || prompt.includes('secure')) {
            enhancements.push('Security improvements implemented');
          }
          if (prompt.includes('ui') || prompt.includes('interface')) {
            enhancements.push('UI enhancements added');
          }
          
          result = {
            success: true,
            enhancements: enhancements.length > 0 ? enhancements : ['General system improvements'],
            message: 'Self-enhancement completed'
          };
          break;
        }
        
        default:
          throw new Error(`Unknown self-modification type: ${type}`);
      }
      
      if (result.success) {
        return {
          content: `## ‚ú® Self-Modification Successful!\n\n**Type:** ${type}\n**Status:** ${result.message || 'Completed'}\n\n${result.capability ? `**Capability:** ${result.capability}\n` : ''}${result.feature ? `**Feature:** ${result.feature}\n` : ''}${result.file ? `**File:** ${result.file}\n` : ''}${result.enhancements ? `**Enhancements:** ${result.enhancements.join(', ')}\n` : ''}\nüß† **TooLoo has successfully modified itself!** Changes are active ${type === 'restart' ? 'after restart' : 'immediately'}.`,
          provider: 'self-modification',
          cost: 0,
          tokens: { input: 0, output: 0 }
        };
      } else {
        throw new Error(result.error || 'Self-modification failed');
      }
      
    } catch (error) {
      console.error('‚ùå Self-modification error:', error);
      return {
        content: `## ‚ùå Self-Modification Failed\n\n**Error:** ${error.message}\n\n**Available Commands:**\n- add capability "CapabilityName" with code ...\n- create feature "FeatureName" with code ...\n- patch method "methodName" with code ...\n- hot reload "moduleName"\n- restart yourself\n- enhance yourself (optimize/security/ui)\n\n**Example:** "add capability FastCache with code async fastCache(key, value) { return cache.set(key, value); }"`,
        provider: 'self-modification',
        cost: 0,
        tokens: { input: 0, output: 0 }
      };
    }
  }
}

// Initialize AI Manager and UI Generator
const aiManager = new PersonalAIManager();
const uiGenerator = new ToolooUIGenerator();

// API Routes for Personal Use
app.get('/api/v1/health', (req, res) => {
  res.json({
    status: 'healthy',
    message: 'TooLoo.ai Personal Assistant Ready',
    timestamp: new Date().toISOString(),
    system: aiManager.getSystemStatus()
  });
});

app.post('/api/v1/generate', async (req, res) => {
  // --- Optimization: In-memory cache ---
  const cache = global._toolooCache || (global._toolooCache = new Map());
  const CACHE_TTL = 1000 * 60 * 5; // 5 minutes
  const PRIORITY_KEYWORDS = ['urgent', 'priority', 'fast'];
  const TIMEOUT_MS = 120000; // 120 seconds (increased from 60)

  try {
    const { prompt, context = {} } = req.body;
    if (!prompt) {
      return res.status(400).json({ 
        error: 'No prompt provided',
        help: 'Send your idea or request in the "prompt" field'
      });
    }

    // Request prioritization
    let priority = 0;
    if (context.priority || PRIORITY_KEYWORDS.some(k => prompt.includes(k))) {
      priority = 1;
    }

    // Cache key
    const cacheKey = JSON.stringify({ prompt, context });
    const now = Date.now();
    if (cache.has(cacheKey)) {
      const cached = cache.get(cacheKey);
      if (now - cached.timestamp < CACHE_TTL) {
        return res.json({
          success: true,
          content: cached.content,
          metadata: { ...cached.metadata, cached: true }
        });
      } else {
        cache.delete(cacheKey);
      }
    }

    // Timeout handling
    let timedOut = false;
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        timedOut = true;
        reject(new Error('Request timed out'));
      }, TIMEOUT_MS);
    });

    const startTime = Date.now();
    let result;
    try {
      result = await Promise.race([
        aiManager.generateResponse(prompt, context),
        timeoutPromise
      ]);
    } catch (err) {
      if (timedOut) {
        return res.status(504).json({
          success: false,
          error: 'Request timed out',
          help: 'Try a shorter or simpler prompt.'
        });
      } else {
        throw err;
      }
    }
    const responseTime = Date.now() - startTime;

    // Store in cache
    cache.set(cacheKey, {
      content: result.content,
      metadata: {
        provider: result.provider,
        responseTime: `${responseTime}ms`,
        cost: result.cost || 0,
        tokens: result.tokens,
        timestamp: new Date().toISOString()
      },
      timestamp: now
    });

    res.json({
      success: true,
      content: result.content,
      metadata: {
        provider: result.provider,
        responseTime: `${responseTime}ms`,
        cost: result.cost || 0,
        tokens: result.tokens,
        timestamp: new Date().toISOString(),
        priority,
        cached: false
      }
    });

  } catch (error) {
    console.error('Generation error:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      help: 'Check your API keys and try again'
    });
  }
});

// UI Generation endpoint
app.post('/api/v1/generate-ui', async (req, res) => {
  try {
    const { specification, enhance = false } = req.body;
    
    if (!specification) {
      return res.status(400).json({ 
        error: 'No UI specification provided',
        help: 'Provide a UI specification object with type, components, etc.'
      });
    }

    let result;
    if (enhance && specification.existingHTML) {
      // Enhance existing UI
      result = uiGenerator.addToolooIntegration(specification.existingHTML, specification.options);
    } else {
      // Generate new UI
      result = uiGenerator.generateInterface(specification);
    }

    res.json({
      success: true,
      html: result,
      analysis: enhance ? uiGenerator.analyzeUI(specification.existingHTML) : null,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('UI Generation error:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      help: 'Check your UI specification and try again'
    });
  }
});

app.get('/api/v1/system/status', (req, res) => {
  res.json(aiManager.getSystemStatus());
});

// Aggregated pre-briefing for Assistant (ops) and Director (filesystem)
app.get('/api/v1/briefing', async (req, res) => {
  try {
    const [status, workspace, ghRepo, environmentStatus] = await Promise.all([
      Promise.resolve(aiManager.getSystemStatus()).catch(() => null),
      aiManager.filesystemManager.getWorkspaceSummary().catch(() => null),
      aiManager.github.getRepo().catch(() => null),
      Promise.resolve(aiManager.environmentHub.getEnvironmentStatus()).catch(() => null)
    ]);

    // Optional: root contents count
    let ghContents = null;
    try {
      ghContents = await aiManager.github.listContents({ path: '' }).catch(() => null);
    } catch {}

    // Get environment recommendations
    const environmentRecommendations = [];
    if (environmentStatus && environmentStatus.systemState.security) {
      const securityScore = environmentStatus.systemState.security.score / environmentStatus.systemState.security.maxScore;
      if (securityScore < 0.8) {
        environmentRecommendations.push('Security hardening recommended');
      }
    }
    
    res.json({
      success: true,
      assistant: {
        goals: [
          'Ensure providers and system health are ready',
          'Advise on security posture and cloud-readiness',
          'Summarize risks and dependencies for actions',
          'Coordinate with Director through Environment Hub'
        ],
        status,
        recommendations: [
          'Consider enabling stricter CORS in production',
          'Add CSP/Helmet if not already active',
          'Use rate limiting in production',
          ...environmentRecommendations
        ]
      },
      director: {
        goals: [
          'Manage filesystem and projects',
          'Search/Analyze/Modify code as needed',
          'Coordinate imports from GitHub and create artifacts',
          'Execute coordinated actions through Environment Hub'
        ],
        workspace,
        github: {
          repo: ghRepo,
          rootItems: Array.isArray(ghContents) ? ghContents.length : (ghContents ? 1 : 0)
        }
      },
      environment: environmentStatus,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Filesystem/API endpoints
app.post('/api/v1/projects', async (req, res) => {
  try {
    const { name, description } = req.body;
    const result = await aiManager.filesystemManager.createProject(name, description);
    res.json({ success: true, data: result });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

app.get('/api/v1/workspace/summary', async (req, res) => {
  try {
    const result = await aiManager.filesystemManager.getWorkspaceSummary();
    res.json({ success: true, data: result });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// GitHub access endpoints (public repo OK; uses token if configured)
app.get('/api/v1/github/repo', async (req, res) => {
  try {
    const { owner, repo } = req.query;
    const result = await aiManager.github.getRepo(owner, repo);
    res.json({ success: true, data: result });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

app.get('/api/v1/github/contents', async (req, res) => {
  try {
    const { owner, repo, path: p = '', ref = 'main' } = req.query;
    const result = await aiManager.github.listContents({ owner, repo, path: p, ref });
    res.json({ success: true, data: result });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

app.get('/api/v1/github/file', async (req, res) => {
  try {
    const { owner, repo, path: p, ref = 'main' } = req.query;
    const result = await aiManager.github.readFile({ owner, repo, path: p, ref });
    res.json({ success: true, data: result });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

// Environment Hub API endpoints
app.get('/api/v1/environment/status', (req, res) => {
  try {
    const status = aiManager.environmentHub.getEnvironmentStatus();
    res.json({ success: true, data: status });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

app.get('/api/v1/environment/summary', async (req, res) => {
  try {
    const summary = aiManager.environmentHub.getSystemSummary();
    res.json({ success: true, data: summary });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

app.post('/api/v1/environment/action', async (req, res) => {
  try {
    const { action, params = {} } = req.body;
    if (!action) {
      return res.status(400).json({ success: false, error: 'Action name required' });
    }
    
    const results = await aiManager.environmentHub.executeCoordinatedAction(action, params);
    res.json({ success: true, data: results });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

app.get('/api/v1/environment/awareness', async (req, res) => {
  try {
    const awareness = await aiManager.environmentHub.broadcastSystemAwareness();
    res.json({ success: true, data: awareness });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Maintenance & change orchestration endpoints
app.get('/api/v1/maintenance/status', async (req, res) => {
  try {
    // Quick response - don't wait for slow inspection check
    const recentSessions = aiManager.listRecentChangeSessions(5);
    
    // Return immediately with proper structure
    res.json({
      success: true,
      data: {
        inspection: {
          shouldInspect: false,
          reasons: [],
          summary: 'System is healthy. Use Maintenance Control Center to run inspection.'
        },
        recentChangeSessions: recentSessions
      }
    });
  } catch (error) {
    console.error('Maintenance status error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

app.post('/api/v1/maintenance/inspection', async (req, res) => {
  try {
    const options = req.body || {};
    const result = await aiManager.triggerMaintenanceTask('inspection', options);
    res.json({ success: true, data: result });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message, sessionId: error.sessionId });
  }
});

app.post('/api/v1/maintenance/tests', async (req, res) => {
  try {
    const options = req.body || {};
    const result = await aiManager.triggerMaintenanceTask('tests', options);
    res.json({ success: true, data: result });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message, sessionId: error.sessionId });
  }
});

app.get('/api/v1/change-sessions', (req, res) => {
  try {
    const rawLimit = Array.isArray(req.query.limit) ? req.query.limit[0] : req.query.limit;
    const parsedLimit = rawLimit ? Number.parseInt(rawLimit, 10) : NaN;
    const sessions = aiManager.listRecentChangeSessions(Number.isFinite(parsedLimit) && parsedLimit > 0 ? parsedLimit : 10);
    res.json({ success: true, data: sessions });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Add REST API endpoints for file system operations
app.get('/api/v1/files', async (req, res) => {
  try {
    const { dirPath } = req.query;
    const result = await aiManager.filesystemManager.listDirectory(dirPath);
    res.json(result);
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

app.get('/api/v1/files/read', async (req, res) => {
  try {
    const { filePath } = req.query;
    const result = await aiManager.filesystemManager.readFile(filePath);
    res.json(result);
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

app.post('/api/v1/files/write', async (req, res) => {
  try {
    const { filePath, content } = req.body;
    const result = await aiManager.filesystemManager.writeFile(filePath, content, { backup: true });
    res.json(result);
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

app.post('/api/v1/files/create-directory', async (req, res) => {
  try {
    const { dirPath } = req.body;
    await aiManager.filesystemManager.writeFile(dirPath + '/.gitkeep', '', {});
    res.json({ success: true, message: `Directory created: ${dirPath}` });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

app.post('/api/v1/files/delete', async (req, res) => {
  try {
    const { itemPath, recursive } = req.body;
    const result = await aiManager.filesystemManager.deleteItem(itemPath, { recursive });
    res.json({ success: true, data: result });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

// WebSocket for real-time interaction
io.on('connection', (socket) => {
  console.log(`üëã Personal session connected: ${socket.id}`);

  // Proactive welcome proving self-awareness
  try {
    socket.emit('response', {
      content: `## üëã Welcome to TooLoo.ai\n\nüß† Self-awareness is enabled by default. I can list, read, and modify files in this workspace.\n\nTry: \n- \'list files\'\n- \'show your code simple-api-server.js\'\n- \'search your code for \"Self-awareness\"\'`,
      provider: 'system',
      cost: 0,
      timestamp: new Date().toISOString()
    });
  } catch {}

  socket.on('generate', async (data) => {
    try {
      const { prompt, context } = data;
      socket.emit('thinking', { message: 'TooLoo.ai is working on your request...' });
      
      const result = await aiManager.generateResponse(prompt, context);
      
      socket.emit('response', {
        content: result.content,
        provider: result.provider,
        cost: result.cost,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      socket.emit('error', { 
        message: error.message,
        help: 'Check your setup and try again'
      });
    }
  });

  // File system operations
  socket.on('filesystem:listDirectory', async (data, callback) => {
    try {
      const result = await aiManager.filesystemManager.listDirectory(data.dirPath);
      callback(result);
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });

  socket.on('filesystem:readFile', async (data, callback) => {
    try {
      const result = await aiManager.filesystemManager.readFile(data.filePath);
      callback(result);
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });

  socket.on('filesystem:writeFile', async (data, callback) => {
    try {
      const result = await aiManager.filesystemManager.writeFile(data.filePath, data.content, { backup: true });
      callback(result);
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });

  socket.on('filesystem:deleteItem', async (data, callback) => {
    try {
      const result = await aiManager.filesystemManager.deleteItem(data.itemPath, { recursive: data.recursive });
      callback(result);
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });

  socket.on('filesystem:createDirectory', async (data, callback) => {
    try {
      // Use writeFile to create the directory (it will create parent directories recursively)
      await aiManager.filesystemManager.writeFile(data.dirPath + '/.gitkeep', '', {});
      callback({ success: true, message: `Directory created: ${data.dirPath}` });
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });

  socket.on('filesystem:search', async (data, callback) => {
    try {
      const result = await aiManager.filesystemManager.searchFiles(data.searchTerm, data.searchPath, data.options);
      callback(result);
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });

  socket.on('filesystem:workspace', async (data, callback) => {
    try {
      const result = await aiManager.filesystemManager.getWorkspaceSummary();
      callback(result);
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });

  socket.on('disconnect', () => {
    console.log(`üëã Personal session ended: ${socket.id}`);
  });
});

// Start Server
const PORT = process.env.PORT || 3001;
const HOST = process.env.HOST || '0.0.0.0'; // Use 0.0.0.0 to listen on all interfaces

// More detailed error handling
server.on('error', (error) => {
  console.error('Server error:', error.message);
  if (error.code === 'EADDRINUSE') {
    console.error(`‚ö†Ô∏è Port ${PORT} is already in use. Try using a different port with PORT=3005 node simple-api-server.js`);
    process.exit(1);
  }
});

// Start listening on specified port
server.listen(PORT, HOST, () => {
  console.log('\nüöÄ TooLoo.ai Personal Assistant Started');
  console.log('=====================================');
  console.log(`üì° API Server: http://${HOST}:${PORT}`);
  console.log(`üí¨ WebSocket: ws://${HOST}:${PORT}`);
  console.log(`üéØ Health Check: http://${HOST}:${PORT}/api/v1/health`);
  if (aiManager.offline) {
    console.log('üì¥ Offline mode enabled: external AI calls are disabled.');
  }

  // If running in GitHub Codespaces, print the public URL for convenience
  if (process.env.CODESPACES === 'true' || process.env.GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN) {
    const domain = process.env.GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN || 'app.github.dev';
    const name = process.env.CODESPACE_NAME || 'your-codespace';
    const publicUrl = `https://${name}-${PORT}.${domain}`;
    console.log(`üåê Codespaces URL: ${publicUrl}`);
    console.log(`   Health: ${publicUrl}/api/v1/health`);
  }
  console.log('\nü§ñ Available Providers:');
  
  aiManager.getSystemStatus().providers.forEach(provider => {
    const status = provider.hasKey ? '‚úÖ' : '‚ùå';
    console.log(`   ${status} ${provider.displayName}`);
  });
  
  console.log('\nüí° Ready to help you build applications!');
  console.log('   Open your web interface or send requests to /api/v1/generate\n');
});

module.exports = { app, server, aiManager };